
build/eviltree.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4822      	ldr	r0, [pc, #136]	; (800014c <endfiniloop+0x4>)
 80000c4:	f380 8809 	msr	PSP, r0
 80000c8:	2002      	movs	r0, #2
 80000ca:	f380 8814 	msr	CONTROL, r0
 80000ce:	f3bf 8f6f 	isb	sy
 80000d2:	f001 fe75 	bl	8001dc0 <__core_init>
 80000d6:	f000 fddb 	bl	8000c90 <__early_init>
 80000da:	481d      	ldr	r0, [pc, #116]	; (8000150 <endfiniloop+0x8>)
 80000dc:	491d      	ldr	r1, [pc, #116]	; (8000154 <endfiniloop+0xc>)
 80000de:	4a1e      	ldr	r2, [pc, #120]	; (8000158 <endfiniloop+0x10>)

080000e0 <msloop>:
 80000e0:	4291      	cmp	r1, r2
 80000e2:	da02      	bge.n	80000ea <endmsloop>
 80000e4:	6008      	str	r0, [r1, #0]
 80000e6:	3104      	adds	r1, #4
 80000e8:	e7fa      	b.n	80000e0 <msloop>

080000ea <endmsloop>:
 80000ea:	491c      	ldr	r1, [pc, #112]	; (800015c <endfiniloop+0x14>)
 80000ec:	4a17      	ldr	r2, [pc, #92]	; (800014c <endfiniloop+0x4>)

080000ee <psloop>:
 80000ee:	4291      	cmp	r1, r2
 80000f0:	da02      	bge.n	80000f8 <endpsloop>
 80000f2:	6008      	str	r0, [r1, #0]
 80000f4:	3104      	adds	r1, #4
 80000f6:	e7fa      	b.n	80000ee <psloop>

080000f8 <endpsloop>:
 80000f8:	4919      	ldr	r1, [pc, #100]	; (8000160 <endfiniloop+0x18>)
 80000fa:	4a1a      	ldr	r2, [pc, #104]	; (8000164 <endfiniloop+0x1c>)
 80000fc:	4b1a      	ldr	r3, [pc, #104]	; (8000168 <endfiniloop+0x20>)

080000fe <dloop>:
 80000fe:	429a      	cmp	r2, r3
 8000100:	da04      	bge.n	800010c <enddloop>
 8000102:	6808      	ldr	r0, [r1, #0]
 8000104:	6010      	str	r0, [r2, #0]
 8000106:	3104      	adds	r1, #4
 8000108:	3204      	adds	r2, #4
 800010a:	e7f8      	b.n	80000fe <dloop>

0800010c <enddloop>:
 800010c:	2000      	movs	r0, #0
 800010e:	4917      	ldr	r1, [pc, #92]	; (800016c <endfiniloop+0x24>)
 8000110:	4a17      	ldr	r2, [pc, #92]	; (8000170 <endfiniloop+0x28>)

08000112 <bloop>:
 8000112:	4291      	cmp	r1, r2
 8000114:	da02      	bge.n	800011c <endbloop>
 8000116:	6008      	str	r0, [r1, #0]
 8000118:	3104      	adds	r1, #4
 800011a:	e7fa      	b.n	8000112 <bloop>

0800011c <endbloop>:
 800011c:	f001 fe68 	bl	8001df0 <__init_ram_areas>
 8000120:	f001 fe56 	bl	8001dd0 <__late_init>
 8000124:	4c13      	ldr	r4, [pc, #76]	; (8000174 <endfiniloop+0x2c>)
 8000126:	4d14      	ldr	r5, [pc, #80]	; (8000178 <endfiniloop+0x30>)

08000128 <initloop>:
 8000128:	42ac      	cmp	r4, r5
 800012a:	da03      	bge.n	8000134 <endinitloop>
 800012c:	6821      	ldr	r1, [r4, #0]
 800012e:	4788      	blx	r1
 8000130:	3404      	adds	r4, #4
 8000132:	e7f9      	b.n	8000128 <initloop>

08000134 <endinitloop>:
 8000134:	f000 f924 	bl	8000380 <main>
 8000138:	4c10      	ldr	r4, [pc, #64]	; (800017c <endfiniloop+0x34>)
 800013a:	4d11      	ldr	r5, [pc, #68]	; (8000180 <endfiniloop+0x38>)

0800013c <finiloop>:
 800013c:	42ac      	cmp	r4, r5
 800013e:	da03      	bge.n	8000148 <endfiniloop>
 8000140:	6821      	ldr	r1, [r4, #0]
 8000142:	4788      	blx	r1
 8000144:	3404      	adds	r4, #4
 8000146:	e7f9      	b.n	800013c <finiloop>

08000148 <endfiniloop>:
 8000148:	490e      	ldr	r1, [pc, #56]	; (8000184 <endfiniloop+0x3c>)
 800014a:	4708      	bx	r1
 800014c:	20000600 	.word	0x20000600
 8000150:	55555555 	.word	0x55555555
 8000154:	20000000 	.word	0x20000000
 8000158:	20000400 	.word	0x20000400
 800015c:	20000400 	.word	0x20000400
 8000160:	08003090 	.word	0x08003090
 8000164:	20000600 	.word	0x20000600
 8000168:	20000668 	.word	0x20000668
 800016c:	20000668 	.word	0x20000668
 8000170:	20000a60 	.word	0x20000a60
 8000174:	080000c0 	.word	0x080000c0
 8000178:	080000c0 	.word	0x080000c0
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	08001de1 	.word	0x08001de1
	...

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	b662      	cpsie	i
 80001b2:	1c28      	adds	r0, r5, #0
 80001b4:	47a0      	blx	r4
 80001b6:	2000      	movs	r0, #0
 80001b8:	f002 fb72 	bl	80028a0 <chThdExit>

080001bc <_port_switch_from_isr>:
 80001bc:	f002 fa10 	bl	80025e0 <chSchDoReschedule>

080001c0 <_port_exit_from_isr>:
 80001c0:	4a01      	ldr	r2, [pc, #4]	; (80001c8 <_port_exit_from_isr+0x8>)
 80001c2:	4b02      	ldr	r3, [pc, #8]	; (80001cc <_port_exit_from_isr+0xc>)
 80001c4:	6013      	str	r3, [r2, #0]
 80001c6:	e7fe      	b.n	80001c6 <_port_exit_from_isr+0x6>
 80001c8:	e000ed04 	.word	0xe000ed04
 80001cc:	80000000 	.word	0x80000000

080001d0 <__aeabi_uidiv>:
 80001d0:	2200      	movs	r2, #0
 80001d2:	0843      	lsrs	r3, r0, #1
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d374      	bcc.n	80002c2 <__aeabi_uidiv+0xf2>
 80001d8:	0903      	lsrs	r3, r0, #4
 80001da:	428b      	cmp	r3, r1
 80001dc:	d35f      	bcc.n	800029e <__aeabi_uidiv+0xce>
 80001de:	0a03      	lsrs	r3, r0, #8
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d344      	bcc.n	800026e <__aeabi_uidiv+0x9e>
 80001e4:	0b03      	lsrs	r3, r0, #12
 80001e6:	428b      	cmp	r3, r1
 80001e8:	d328      	bcc.n	800023c <__aeabi_uidiv+0x6c>
 80001ea:	0c03      	lsrs	r3, r0, #16
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d30d      	bcc.n	800020c <__aeabi_uidiv+0x3c>
 80001f0:	22ff      	movs	r2, #255	; 0xff
 80001f2:	0209      	lsls	r1, r1, #8
 80001f4:	ba12      	rev	r2, r2
 80001f6:	0c03      	lsrs	r3, r0, #16
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d302      	bcc.n	8000202 <__aeabi_uidiv+0x32>
 80001fc:	1212      	asrs	r2, r2, #8
 80001fe:	0209      	lsls	r1, r1, #8
 8000200:	d065      	beq.n	80002ce <__aeabi_uidiv+0xfe>
 8000202:	0b03      	lsrs	r3, r0, #12
 8000204:	428b      	cmp	r3, r1
 8000206:	d319      	bcc.n	800023c <__aeabi_uidiv+0x6c>
 8000208:	e000      	b.n	800020c <__aeabi_uidiv+0x3c>
 800020a:	0a09      	lsrs	r1, r1, #8
 800020c:	0bc3      	lsrs	r3, r0, #15
 800020e:	428b      	cmp	r3, r1
 8000210:	d301      	bcc.n	8000216 <__aeabi_uidiv+0x46>
 8000212:	03cb      	lsls	r3, r1, #15
 8000214:	1ac0      	subs	r0, r0, r3
 8000216:	4152      	adcs	r2, r2
 8000218:	0b83      	lsrs	r3, r0, #14
 800021a:	428b      	cmp	r3, r1
 800021c:	d301      	bcc.n	8000222 <__aeabi_uidiv+0x52>
 800021e:	038b      	lsls	r3, r1, #14
 8000220:	1ac0      	subs	r0, r0, r3
 8000222:	4152      	adcs	r2, r2
 8000224:	0b43      	lsrs	r3, r0, #13
 8000226:	428b      	cmp	r3, r1
 8000228:	d301      	bcc.n	800022e <__aeabi_uidiv+0x5e>
 800022a:	034b      	lsls	r3, r1, #13
 800022c:	1ac0      	subs	r0, r0, r3
 800022e:	4152      	adcs	r2, r2
 8000230:	0b03      	lsrs	r3, r0, #12
 8000232:	428b      	cmp	r3, r1
 8000234:	d301      	bcc.n	800023a <__aeabi_uidiv+0x6a>
 8000236:	030b      	lsls	r3, r1, #12
 8000238:	1ac0      	subs	r0, r0, r3
 800023a:	4152      	adcs	r2, r2
 800023c:	0ac3      	lsrs	r3, r0, #11
 800023e:	428b      	cmp	r3, r1
 8000240:	d301      	bcc.n	8000246 <__aeabi_uidiv+0x76>
 8000242:	02cb      	lsls	r3, r1, #11
 8000244:	1ac0      	subs	r0, r0, r3
 8000246:	4152      	adcs	r2, r2
 8000248:	0a83      	lsrs	r3, r0, #10
 800024a:	428b      	cmp	r3, r1
 800024c:	d301      	bcc.n	8000252 <__aeabi_uidiv+0x82>
 800024e:	028b      	lsls	r3, r1, #10
 8000250:	1ac0      	subs	r0, r0, r3
 8000252:	4152      	adcs	r2, r2
 8000254:	0a43      	lsrs	r3, r0, #9
 8000256:	428b      	cmp	r3, r1
 8000258:	d301      	bcc.n	800025e <__aeabi_uidiv+0x8e>
 800025a:	024b      	lsls	r3, r1, #9
 800025c:	1ac0      	subs	r0, r0, r3
 800025e:	4152      	adcs	r2, r2
 8000260:	0a03      	lsrs	r3, r0, #8
 8000262:	428b      	cmp	r3, r1
 8000264:	d301      	bcc.n	800026a <__aeabi_uidiv+0x9a>
 8000266:	020b      	lsls	r3, r1, #8
 8000268:	1ac0      	subs	r0, r0, r3
 800026a:	4152      	adcs	r2, r2
 800026c:	d2cd      	bcs.n	800020a <__aeabi_uidiv+0x3a>
 800026e:	09c3      	lsrs	r3, r0, #7
 8000270:	428b      	cmp	r3, r1
 8000272:	d301      	bcc.n	8000278 <__aeabi_uidiv+0xa8>
 8000274:	01cb      	lsls	r3, r1, #7
 8000276:	1ac0      	subs	r0, r0, r3
 8000278:	4152      	adcs	r2, r2
 800027a:	0983      	lsrs	r3, r0, #6
 800027c:	428b      	cmp	r3, r1
 800027e:	d301      	bcc.n	8000284 <__aeabi_uidiv+0xb4>
 8000280:	018b      	lsls	r3, r1, #6
 8000282:	1ac0      	subs	r0, r0, r3
 8000284:	4152      	adcs	r2, r2
 8000286:	0943      	lsrs	r3, r0, #5
 8000288:	428b      	cmp	r3, r1
 800028a:	d301      	bcc.n	8000290 <__aeabi_uidiv+0xc0>
 800028c:	014b      	lsls	r3, r1, #5
 800028e:	1ac0      	subs	r0, r0, r3
 8000290:	4152      	adcs	r2, r2
 8000292:	0903      	lsrs	r3, r0, #4
 8000294:	428b      	cmp	r3, r1
 8000296:	d301      	bcc.n	800029c <__aeabi_uidiv+0xcc>
 8000298:	010b      	lsls	r3, r1, #4
 800029a:	1ac0      	subs	r0, r0, r3
 800029c:	4152      	adcs	r2, r2
 800029e:	08c3      	lsrs	r3, r0, #3
 80002a0:	428b      	cmp	r3, r1
 80002a2:	d301      	bcc.n	80002a8 <__aeabi_uidiv+0xd8>
 80002a4:	00cb      	lsls	r3, r1, #3
 80002a6:	1ac0      	subs	r0, r0, r3
 80002a8:	4152      	adcs	r2, r2
 80002aa:	0883      	lsrs	r3, r0, #2
 80002ac:	428b      	cmp	r3, r1
 80002ae:	d301      	bcc.n	80002b4 <__aeabi_uidiv+0xe4>
 80002b0:	008b      	lsls	r3, r1, #2
 80002b2:	1ac0      	subs	r0, r0, r3
 80002b4:	4152      	adcs	r2, r2
 80002b6:	0843      	lsrs	r3, r0, #1
 80002b8:	428b      	cmp	r3, r1
 80002ba:	d301      	bcc.n	80002c0 <__aeabi_uidiv+0xf0>
 80002bc:	004b      	lsls	r3, r1, #1
 80002be:	1ac0      	subs	r0, r0, r3
 80002c0:	4152      	adcs	r2, r2
 80002c2:	1a41      	subs	r1, r0, r1
 80002c4:	d200      	bcs.n	80002c8 <__aeabi_uidiv+0xf8>
 80002c6:	4601      	mov	r1, r0
 80002c8:	4152      	adcs	r2, r2
 80002ca:	4610      	mov	r0, r2
 80002cc:	4770      	bx	lr
 80002ce:	e7ff      	b.n	80002d0 <__aeabi_uidiv+0x100>
 80002d0:	b501      	push	{r0, lr}
 80002d2:	2000      	movs	r0, #0
 80002d4:	f000 f80c 	bl	80002f0 <__aeabi_idiv0>
 80002d8:	bd02      	pop	{r1, pc}
 80002da:	46c0      	nop			; (mov r8, r8)

080002dc <__aeabi_uidivmod>:
 80002dc:	2900      	cmp	r1, #0
 80002de:	d0f7      	beq.n	80002d0 <__aeabi_uidiv+0x100>
 80002e0:	e776      	b.n	80001d0 <__aeabi_uidiv>
 80002e2:	4770      	bx	lr
	...

080002f0 <__aeabi_idiv0>:
 80002f0:	4770      	bx	lr
 80002f2:	46c0      	nop			; (mov r8, r8)
	...

08000300 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000300:	b082      	sub	sp, #8
 8000302:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8000304:	4b02      	ldr	r3, [pc, #8]	; (8000310 <chRegSetThreadName+0x10>)
 8000306:	699b      	ldr	r3, [r3, #24]
 8000308:	9a01      	ldr	r2, [sp, #4]
 800030a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800030c:	b002      	add	sp, #8
 800030e:	4770      	bx	lr
 8000310:	20000668 	.word	0x20000668
	...

08000320 <pwmpcb>:
/* Function Prototypes */
static void fadeUp(uint8_t time);                       /* time = Fade Duration in (Integer) Seconds */
static void fadeDown(uint8_t time);

/* PWM Callback Functions */
static void pwmpcb(PWMDriver *pwmp) {
 8000320:	b082      	sub	sp, #8
 8000322:	9001      	str	r0, [sp, #4]

  (void)pwmp;
  palSetPad(GPIOA, GPIOA_LED5);
 8000324:	2390      	movs	r3, #144	; 0x90
 8000326:	05db      	lsls	r3, r3, #23
 8000328:	2210      	movs	r2, #16
 800032a:	831a      	strh	r2, [r3, #24]
  palSetPad(GPIOF, GPIOF_LED2);
 800032c:	4b03      	ldr	r3, [pc, #12]	; (800033c <pwmpcb+0x1c>)
 800032e:	2201      	movs	r2, #1
 8000330:	831a      	strh	r2, [r3, #24]
  palSetPad(GPIOF, GPIOF_LED3);
 8000332:	4b02      	ldr	r3, [pc, #8]	; (800033c <pwmpcb+0x1c>)
 8000334:	2202      	movs	r2, #2
 8000336:	831a      	strh	r2, [r3, #24]
}
 8000338:	b002      	add	sp, #8
 800033a:	4770      	bx	lr
 800033c:	48001400 	.word	0x48001400

08000340 <pwmc1cb>:

static void pwmc1cb(PWMDriver *pwmp) {
 8000340:	b082      	sub	sp, #8
 8000342:	9001      	str	r0, [sp, #4]

  (void)pwmp;
  palClearPad(GPIOA, GPIOA_LED5);
 8000344:	2390      	movs	r3, #144	; 0x90
 8000346:	05db      	lsls	r3, r3, #23
 8000348:	2210      	movs	r2, #16
 800034a:	835a      	strh	r2, [r3, #26]
  palClearPad(GPIOF, GPIOF_LED2);
 800034c:	4b03      	ldr	r3, [pc, #12]	; (800035c <pwmc1cb+0x1c>)
 800034e:	2201      	movs	r2, #1
 8000350:	835a      	strh	r2, [r3, #26]
  palClearPad(GPIOF, GPIOF_LED3);
 8000352:	4b02      	ldr	r3, [pc, #8]	; (800035c <pwmc1cb+0x1c>)
 8000354:	2202      	movs	r2, #2
 8000356:	835a      	strh	r2, [r3, #26]
}
 8000358:	b002      	add	sp, #8
 800035a:	4770      	bx	lr
 800035c:	48001400 	.word	0x48001400

08000360 <thd_LED>:
  0
};

/* LED Pattern Thread */
static THD_WORKING_AREA(wa_LED, 256);
static THD_FUNCTION(thd_LED, arg) {
 8000360:	b500      	push	{lr}
 8000362:	b083      	sub	sp, #12
 8000364:	9001      	str	r0, [sp, #4]

    (void)arg;
    chRegSetThreadName("LED");
 8000366:	4b05      	ldr	r3, [pc, #20]	; (800037c <thd_LED+0x1c>)
 8000368:	0018      	movs	r0, r3
 800036a:	f7ff ffc9 	bl	8000300 <chRegSetThreadName>
      
    /* LED Sequence */
    while(TRUE) {
        fadeUp(8);
 800036e:	2008      	movs	r0, #8
 8000370:	f000 f83e 	bl	80003f0 <fadeUp>
        fadeDown(8);
 8000374:	2008      	movs	r0, #8
 8000376:	f000 f8cb 	bl	8000510 <fadeDown>
 800037a:	e7f8      	b.n	800036e <thd_LED+0xe>
 800037c:	08002f24 	.word	0x08002f24

08000380 <main>:
    }
}


/* Application Entry Point */
int main(void) {
 8000380:	b500      	push	{lr}
 8000382:	b083      	sub	sp, #12

    /* System Init */
    halInit();
 8000384:	f001 fc4c 	bl	8001c20 <halInit>
    chSysInit();
 8000388:	f001 fe92 	bl	80020b0 <chSysInit>
    
    /* PWM Init */
    pwmStart(&PWMD2, &pwm2cfg);
 800038c:	4a11      	ldr	r2, [pc, #68]	; (80003d4 <main+0x54>)
 800038e:	4b12      	ldr	r3, [pc, #72]	; (80003d8 <main+0x58>)
 8000390:	0011      	movs	r1, r2
 8000392:	0018      	movs	r0, r3
 8000394:	f000 fcd4 	bl	8000d40 <pwmStart>
    pwmStart(&PWMD3, &pwm3cfg);  
 8000398:	4a10      	ldr	r2, [pc, #64]	; (80003dc <main+0x5c>)
 800039a:	4b11      	ldr	r3, [pc, #68]	; (80003e0 <main+0x60>)
 800039c:	0011      	movs	r1, r2
 800039e:	0018      	movs	r0, r3
 80003a0:	f000 fcce 	bl	8000d40 <pwmStart>
    pwmEnablePeriodicNotification(&PWMD2);
 80003a4:	4b0c      	ldr	r3, [pc, #48]	; (80003d8 <main+0x58>)
 80003a6:	0018      	movs	r0, r3
 80003a8:	f000 fd12 	bl	8000dd0 <pwmEnablePeriodicNotification>
    pwmEnableChannelNotification(&PWMD2, 0);
 80003ac:	4b0a      	ldr	r3, [pc, #40]	; (80003d8 <main+0x58>)
 80003ae:	2100      	movs	r1, #0
 80003b0:	0018      	movs	r0, r3
 80003b2:	f000 fd1d 	bl	8000df0 <pwmEnableChannelNotification>
    
    /* Create LED Pattern Thread */
    chThdCreateStatic(wa_LED, sizeof(wa_LED), NORMALPRIO, thd_LED, NULL);
 80003b6:	4a0b      	ldr	r2, [pc, #44]	; (80003e4 <main+0x64>)
 80003b8:	23e4      	movs	r3, #228	; 0xe4
 80003ba:	0059      	lsls	r1, r3, #1
 80003bc:	480a      	ldr	r0, [pc, #40]	; (80003e8 <main+0x68>)
 80003be:	2300      	movs	r3, #0
 80003c0:	9300      	str	r3, [sp, #0]
 80003c2:	0013      	movs	r3, r2
 80003c4:	2240      	movs	r2, #64	; 0x40
 80003c6:	f002 fa3b 	bl	8002840 <chThdCreateStatic>

    /* Do Nothing */
    while (true) {
        chThdSleepMilliseconds(1000);
 80003ca:	4b08      	ldr	r3, [pc, #32]	; (80003ec <main+0x6c>)
 80003cc:	0018      	movs	r0, r3
 80003ce:	f002 fa57 	bl	8002880 <chThdSleep>
 80003d2:	e7fa      	b.n	80003ca <main+0x4a>
 80003d4:	20000600 	.word	0x20000600
 80003d8:	200007e0 	.word	0x200007e0
 80003dc:	20000634 	.word	0x20000634
 80003e0:	200007fc 	.word	0x200007fc
 80003e4:	08000361 	.word	0x08000361
 80003e8:	20000898 	.word	0x20000898
 80003ec:	00002710 	.word	0x00002710

080003f0 <fadeUp>:
    }
}

static void fadeUp(uint8_t time) {
 80003f0:	b500      	push	{lr}
 80003f2:	b085      	sub	sp, #20
 80003f4:	0002      	movs	r2, r0
 80003f6:	466b      	mov	r3, sp
 80003f8:	3307      	adds	r3, #7
 80003fa:	701a      	strb	r2, [r3, #0]
    
    uint16_t percent = 1000;
 80003fc:	230e      	movs	r3, #14
 80003fe:	446b      	add	r3, sp
 8000400:	22fa      	movs	r2, #250	; 0xfa
 8000402:	0092      	lsls	r2, r2, #2
 8000404:	801a      	strh	r2, [r3, #0]
 8000406:	e06b      	b.n	80004e0 <fadeUp+0xf0>
    
    while (percent < 10000) {
            
        /* Set PWM Duty Cycle */
        pwmEnableChannel(&PWMD2, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, percent));
 8000408:	4b39      	ldr	r3, [pc, #228]	; (80004f0 <fadeUp+0x100>)
 800040a:	689b      	ldr	r3, [r3, #8]
 800040c:	220e      	movs	r2, #14
 800040e:	446a      	add	r2, sp
 8000410:	8812      	ldrh	r2, [r2, #0]
 8000412:	4353      	muls	r3, r2
 8000414:	4937      	ldr	r1, [pc, #220]	; (80004f4 <fadeUp+0x104>)
 8000416:	0018      	movs	r0, r3
 8000418:	f7ff feda 	bl	80001d0 <__aeabi_uidiv>
 800041c:	0003      	movs	r3, r0
 800041e:	001a      	movs	r2, r3
 8000420:	4b33      	ldr	r3, [pc, #204]	; (80004f0 <fadeUp+0x100>)
 8000422:	2100      	movs	r1, #0
 8000424:	0018      	movs	r0, r3
 8000426:	f000 fcab 	bl	8000d80 <pwmEnableChannel>
        pwmEnableChannel(&PWMD2, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, percent));    
 800042a:	4b31      	ldr	r3, [pc, #196]	; (80004f0 <fadeUp+0x100>)
 800042c:	689b      	ldr	r3, [r3, #8]
 800042e:	220e      	movs	r2, #14
 8000430:	446a      	add	r2, sp
 8000432:	8812      	ldrh	r2, [r2, #0]
 8000434:	4353      	muls	r3, r2
 8000436:	492f      	ldr	r1, [pc, #188]	; (80004f4 <fadeUp+0x104>)
 8000438:	0018      	movs	r0, r3
 800043a:	f7ff fec9 	bl	80001d0 <__aeabi_uidiv>
 800043e:	0003      	movs	r3, r0
 8000440:	001a      	movs	r2, r3
 8000442:	4b2b      	ldr	r3, [pc, #172]	; (80004f0 <fadeUp+0x100>)
 8000444:	2101      	movs	r1, #1
 8000446:	0018      	movs	r0, r3
 8000448:	f000 fc9a 	bl	8000d80 <pwmEnableChannel>
        pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, percent));
 800044c:	4b2a      	ldr	r3, [pc, #168]	; (80004f8 <fadeUp+0x108>)
 800044e:	689b      	ldr	r3, [r3, #8]
 8000450:	220e      	movs	r2, #14
 8000452:	446a      	add	r2, sp
 8000454:	8812      	ldrh	r2, [r2, #0]
 8000456:	4353      	muls	r3, r2
 8000458:	4926      	ldr	r1, [pc, #152]	; (80004f4 <fadeUp+0x104>)
 800045a:	0018      	movs	r0, r3
 800045c:	f7ff feb8 	bl	80001d0 <__aeabi_uidiv>
 8000460:	0003      	movs	r3, r0
 8000462:	001a      	movs	r2, r3
 8000464:	4b24      	ldr	r3, [pc, #144]	; (80004f8 <fadeUp+0x108>)
 8000466:	2100      	movs	r1, #0
 8000468:	0018      	movs	r0, r3
 800046a:	f000 fc89 	bl	8000d80 <pwmEnableChannel>
        pwmEnableChannel(&PWMD3, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, percent));
 800046e:	4b22      	ldr	r3, [pc, #136]	; (80004f8 <fadeUp+0x108>)
 8000470:	689b      	ldr	r3, [r3, #8]
 8000472:	220e      	movs	r2, #14
 8000474:	446a      	add	r2, sp
 8000476:	8812      	ldrh	r2, [r2, #0]
 8000478:	4353      	muls	r3, r2
 800047a:	491e      	ldr	r1, [pc, #120]	; (80004f4 <fadeUp+0x104>)
 800047c:	0018      	movs	r0, r3
 800047e:	f7ff fea7 	bl	80001d0 <__aeabi_uidiv>
 8000482:	0003      	movs	r3, r0
 8000484:	001a      	movs	r2, r3
 8000486:	4b1c      	ldr	r3, [pc, #112]	; (80004f8 <fadeUp+0x108>)
 8000488:	2101      	movs	r1, #1
 800048a:	0018      	movs	r0, r3
 800048c:	f000 fc78 	bl	8000d80 <pwmEnableChannel>
        pwmEnableChannel(&PWMD3, 3, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, percent));
 8000490:	4b19      	ldr	r3, [pc, #100]	; (80004f8 <fadeUp+0x108>)
 8000492:	689b      	ldr	r3, [r3, #8]
 8000494:	220e      	movs	r2, #14
 8000496:	446a      	add	r2, sp
 8000498:	8812      	ldrh	r2, [r2, #0]
 800049a:	4353      	muls	r3, r2
 800049c:	4915      	ldr	r1, [pc, #84]	; (80004f4 <fadeUp+0x104>)
 800049e:	0018      	movs	r0, r3
 80004a0:	f7ff fe96 	bl	80001d0 <__aeabi_uidiv>
 80004a4:	0003      	movs	r3, r0
 80004a6:	001a      	movs	r2, r3
 80004a8:	4b13      	ldr	r3, [pc, #76]	; (80004f8 <fadeUp+0x108>)
 80004aa:	2103      	movs	r1, #3
 80004ac:	0018      	movs	r0, r3
 80004ae:	f000 fc67 	bl	8000d80 <pwmEnableChannel>
        
        /* Update Loop Counter */
        percent = percent + 10;
 80004b2:	230e      	movs	r3, #14
 80004b4:	446b      	add	r3, sp
 80004b6:	220e      	movs	r2, #14
 80004b8:	446a      	add	r2, sp
 80004ba:	8812      	ldrh	r2, [r2, #0]
 80004bc:	320a      	adds	r2, #10
 80004be:	801a      	strh	r2, [r3, #0]
        chThdSleepMilliseconds(time);
 80004c0:	466b      	mov	r3, sp
 80004c2:	3307      	adds	r3, #7
 80004c4:	781b      	ldrb	r3, [r3, #0]
 80004c6:	4a0b      	ldr	r2, [pc, #44]	; (80004f4 <fadeUp+0x104>)
 80004c8:	4353      	muls	r3, r2
 80004ca:	4a0c      	ldr	r2, [pc, #48]	; (80004fc <fadeUp+0x10c>)
 80004cc:	189a      	adds	r2, r3, r2
 80004ce:	23fa      	movs	r3, #250	; 0xfa
 80004d0:	0099      	lsls	r1, r3, #2
 80004d2:	0010      	movs	r0, r2
 80004d4:	f7ff fe7c 	bl	80001d0 <__aeabi_uidiv>
 80004d8:	0003      	movs	r3, r0
 80004da:	0018      	movs	r0, r3
 80004dc:	f002 f9d0 	bl	8002880 <chThdSleep>

static void fadeUp(uint8_t time) {
    
    uint16_t percent = 1000;
    
    while (percent < 10000) {
 80004e0:	230e      	movs	r3, #14
 80004e2:	446b      	add	r3, sp
 80004e4:	881b      	ldrh	r3, [r3, #0]
 80004e6:	4a06      	ldr	r2, [pc, #24]	; (8000500 <fadeUp+0x110>)
 80004e8:	4293      	cmp	r3, r2
 80004ea:	d98d      	bls.n	8000408 <fadeUp+0x18>
        
        /* Update Loop Counter */
        percent = percent + 10;
        chThdSleepMilliseconds(time);
    }
}
 80004ec:	b005      	add	sp, #20
 80004ee:	bd00      	pop	{pc}
 80004f0:	200007e0 	.word	0x200007e0
 80004f4:	00002710 	.word	0x00002710
 80004f8:	200007fc 	.word	0x200007fc
 80004fc:	000003e7 	.word	0x000003e7
 8000500:	0000270f 	.word	0x0000270f
	...

08000510 <fadeDown>:


static void fadeDown(uint8_t time) {
 8000510:	b500      	push	{lr}
 8000512:	b085      	sub	sp, #20
 8000514:	0002      	movs	r2, r0
 8000516:	466b      	mov	r3, sp
 8000518:	3307      	adds	r3, #7
 800051a:	701a      	strb	r2, [r3, #0]
    
    uint16_t percent = 10000;
 800051c:	230e      	movs	r3, #14
 800051e:	446b      	add	r3, sp
 8000520:	4a3b      	ldr	r2, [pc, #236]	; (8000610 <fadeDown+0x100>)
 8000522:	801a      	strh	r2, [r3, #0]
 8000524:	e06b      	b.n	80005fe <fadeDown+0xee>
    
    while (percent > 1000) {
            
        /* Set PWM Duty Cycle */
        pwmEnableChannel(&PWMD2, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, percent));
 8000526:	4b3b      	ldr	r3, [pc, #236]	; (8000614 <fadeDown+0x104>)
 8000528:	689b      	ldr	r3, [r3, #8]
 800052a:	220e      	movs	r2, #14
 800052c:	446a      	add	r2, sp
 800052e:	8812      	ldrh	r2, [r2, #0]
 8000530:	4353      	muls	r3, r2
 8000532:	4937      	ldr	r1, [pc, #220]	; (8000610 <fadeDown+0x100>)
 8000534:	0018      	movs	r0, r3
 8000536:	f7ff fe4b 	bl	80001d0 <__aeabi_uidiv>
 800053a:	0003      	movs	r3, r0
 800053c:	001a      	movs	r2, r3
 800053e:	4b35      	ldr	r3, [pc, #212]	; (8000614 <fadeDown+0x104>)
 8000540:	2100      	movs	r1, #0
 8000542:	0018      	movs	r0, r3
 8000544:	f000 fc1c 	bl	8000d80 <pwmEnableChannel>
        pwmEnableChannel(&PWMD2, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, percent));    
 8000548:	4b32      	ldr	r3, [pc, #200]	; (8000614 <fadeDown+0x104>)
 800054a:	689b      	ldr	r3, [r3, #8]
 800054c:	220e      	movs	r2, #14
 800054e:	446a      	add	r2, sp
 8000550:	8812      	ldrh	r2, [r2, #0]
 8000552:	4353      	muls	r3, r2
 8000554:	492e      	ldr	r1, [pc, #184]	; (8000610 <fadeDown+0x100>)
 8000556:	0018      	movs	r0, r3
 8000558:	f7ff fe3a 	bl	80001d0 <__aeabi_uidiv>
 800055c:	0003      	movs	r3, r0
 800055e:	001a      	movs	r2, r3
 8000560:	4b2c      	ldr	r3, [pc, #176]	; (8000614 <fadeDown+0x104>)
 8000562:	2101      	movs	r1, #1
 8000564:	0018      	movs	r0, r3
 8000566:	f000 fc0b 	bl	8000d80 <pwmEnableChannel>
        pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, percent));
 800056a:	4b2b      	ldr	r3, [pc, #172]	; (8000618 <fadeDown+0x108>)
 800056c:	689b      	ldr	r3, [r3, #8]
 800056e:	220e      	movs	r2, #14
 8000570:	446a      	add	r2, sp
 8000572:	8812      	ldrh	r2, [r2, #0]
 8000574:	4353      	muls	r3, r2
 8000576:	4926      	ldr	r1, [pc, #152]	; (8000610 <fadeDown+0x100>)
 8000578:	0018      	movs	r0, r3
 800057a:	f7ff fe29 	bl	80001d0 <__aeabi_uidiv>
 800057e:	0003      	movs	r3, r0
 8000580:	001a      	movs	r2, r3
 8000582:	4b25      	ldr	r3, [pc, #148]	; (8000618 <fadeDown+0x108>)
 8000584:	2100      	movs	r1, #0
 8000586:	0018      	movs	r0, r3
 8000588:	f000 fbfa 	bl	8000d80 <pwmEnableChannel>
        pwmEnableChannel(&PWMD3, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, percent));
 800058c:	4b22      	ldr	r3, [pc, #136]	; (8000618 <fadeDown+0x108>)
 800058e:	689b      	ldr	r3, [r3, #8]
 8000590:	220e      	movs	r2, #14
 8000592:	446a      	add	r2, sp
 8000594:	8812      	ldrh	r2, [r2, #0]
 8000596:	4353      	muls	r3, r2
 8000598:	491d      	ldr	r1, [pc, #116]	; (8000610 <fadeDown+0x100>)
 800059a:	0018      	movs	r0, r3
 800059c:	f7ff fe18 	bl	80001d0 <__aeabi_uidiv>
 80005a0:	0003      	movs	r3, r0
 80005a2:	001a      	movs	r2, r3
 80005a4:	4b1c      	ldr	r3, [pc, #112]	; (8000618 <fadeDown+0x108>)
 80005a6:	2101      	movs	r1, #1
 80005a8:	0018      	movs	r0, r3
 80005aa:	f000 fbe9 	bl	8000d80 <pwmEnableChannel>
        pwmEnableChannel(&PWMD3, 3, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, percent));
 80005ae:	4b1a      	ldr	r3, [pc, #104]	; (8000618 <fadeDown+0x108>)
 80005b0:	689b      	ldr	r3, [r3, #8]
 80005b2:	220e      	movs	r2, #14
 80005b4:	446a      	add	r2, sp
 80005b6:	8812      	ldrh	r2, [r2, #0]
 80005b8:	4353      	muls	r3, r2
 80005ba:	4915      	ldr	r1, [pc, #84]	; (8000610 <fadeDown+0x100>)
 80005bc:	0018      	movs	r0, r3
 80005be:	f7ff fe07 	bl	80001d0 <__aeabi_uidiv>
 80005c2:	0003      	movs	r3, r0
 80005c4:	001a      	movs	r2, r3
 80005c6:	4b14      	ldr	r3, [pc, #80]	; (8000618 <fadeDown+0x108>)
 80005c8:	2103      	movs	r1, #3
 80005ca:	0018      	movs	r0, r3
 80005cc:	f000 fbd8 	bl	8000d80 <pwmEnableChannel>
        
        /* Update Loop Counter */
        percent = percent - 10;
 80005d0:	230e      	movs	r3, #14
 80005d2:	446b      	add	r3, sp
 80005d4:	220e      	movs	r2, #14
 80005d6:	446a      	add	r2, sp
 80005d8:	8812      	ldrh	r2, [r2, #0]
 80005da:	3a0a      	subs	r2, #10
 80005dc:	801a      	strh	r2, [r3, #0]
        chThdSleepMilliseconds(time);
 80005de:	466b      	mov	r3, sp
 80005e0:	3307      	adds	r3, #7
 80005e2:	781b      	ldrb	r3, [r3, #0]
 80005e4:	4a0a      	ldr	r2, [pc, #40]	; (8000610 <fadeDown+0x100>)
 80005e6:	4353      	muls	r3, r2
 80005e8:	4a0c      	ldr	r2, [pc, #48]	; (800061c <fadeDown+0x10c>)
 80005ea:	189a      	adds	r2, r3, r2
 80005ec:	23fa      	movs	r3, #250	; 0xfa
 80005ee:	0099      	lsls	r1, r3, #2
 80005f0:	0010      	movs	r0, r2
 80005f2:	f7ff fded 	bl	80001d0 <__aeabi_uidiv>
 80005f6:	0003      	movs	r3, r0
 80005f8:	0018      	movs	r0, r3
 80005fa:	f002 f941 	bl	8002880 <chThdSleep>

static void fadeDown(uint8_t time) {
    
    uint16_t percent = 10000;
    
    while (percent > 1000) {
 80005fe:	230e      	movs	r3, #14
 8000600:	446b      	add	r3, sp
 8000602:	881a      	ldrh	r2, [r3, #0]
 8000604:	23fa      	movs	r3, #250	; 0xfa
 8000606:	009b      	lsls	r3, r3, #2
 8000608:	429a      	cmp	r2, r3
 800060a:	d88c      	bhi.n	8000526 <fadeDown+0x16>
        
        /* Update Loop Counter */
        percent = percent - 10;
        chThdSleepMilliseconds(time);
    }
}
 800060c:	b005      	add	sp, #20
 800060e:	bd00      	pop	{pc}
 8000610:	00002710 	.word	0x00002710
 8000614:	200007e0 	.word	0x200007e0
 8000618:	200007fc 	.word	0x200007fc
 800061c:	000003e7 	.word	0x000003e7

08000620 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 8000620:	b510      	push	{r4, lr}
  PWMD1.tim = STM32_TIM1;
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
 8000622:	4b0b      	ldr	r3, [pc, #44]	; (8000650 <pwm_lld_init+0x30>)
 8000624:	0018      	movs	r0, r3
 8000626:	f000 fb7b 	bl	8000d20 <pwmObjectInit>
  PWMD2.channels = STM32_TIM2_CHANNELS;
 800062a:	4b09      	ldr	r3, [pc, #36]	; (8000650 <pwm_lld_init+0x30>)
 800062c:	2204      	movs	r2, #4
 800062e:	741a      	strb	r2, [r3, #16]
  PWMD2.tim = STM32_TIM2;
 8000630:	4b07      	ldr	r3, [pc, #28]	; (8000650 <pwm_lld_init+0x30>)
 8000632:	2280      	movs	r2, #128	; 0x80
 8000634:	05d2      	lsls	r2, r2, #23
 8000636:	619a      	str	r2, [r3, #24]
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8000638:	4b06      	ldr	r3, [pc, #24]	; (8000654 <pwm_lld_init+0x34>)
 800063a:	0018      	movs	r0, r3
 800063c:	f000 fb70 	bl	8000d20 <pwmObjectInit>
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8000640:	4b04      	ldr	r3, [pc, #16]	; (8000654 <pwm_lld_init+0x34>)
 8000642:	2204      	movs	r2, #4
 8000644:	741a      	strb	r2, [r3, #16]
  PWMD3.tim = STM32_TIM3;
 8000646:	4b03      	ldr	r3, [pc, #12]	; (8000654 <pwm_lld_init+0x34>)
 8000648:	4a03      	ldr	r2, [pc, #12]	; (8000658 <pwm_lld_init+0x38>)
 800064a:	619a      	str	r2, [r3, #24]
  /* Driver initialization.*/
  pwmObjectInit(&PWMD9);
  PWMD9.channels = STM32_TIM9_CHANNELS;
  PWMD9.tim = STM32_TIM9;
#endif
}
 800064c:	bd10      	pop	{r4, pc}
 800064e:	46c0      	nop			; (mov r8, r8)
 8000650:	200007e0 	.word	0x200007e0
 8000654:	200007fc 	.word	0x200007fc
 8000658:	40000400 	.word	0x40000400
 800065c:	00000000 	.word	0x00000000

08000660 <pwm_lld_start>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 8000660:	b500      	push	{lr}
 8000662:	b085      	sub	sp, #20
 8000664:	9001      	str	r0, [sp, #4]
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 8000666:	9b01      	ldr	r3, [sp, #4]
 8000668:	781b      	ldrb	r3, [r3, #0]
 800066a:	2b01      	cmp	r3, #1
 800066c:	d13c      	bne.n	80006e8 <pwm_lld_start+0x88>
#endif
    }
#endif

#if STM32_PWM_USE_TIM2
    if (&PWMD2 == pwmp) {
 800066e:	9a01      	ldr	r2, [sp, #4]
 8000670:	4b69      	ldr	r3, [pc, #420]	; (8000818 <pwm_lld_start+0x1b8>)
 8000672:	429a      	cmp	r2, r3
 8000674:	d115      	bne.n	80006a2 <pwm_lld_start+0x42>
      rccEnableTIM2(FALSE);
 8000676:	4b69      	ldr	r3, [pc, #420]	; (800081c <pwm_lld_start+0x1bc>)
 8000678:	4a68      	ldr	r2, [pc, #416]	; (800081c <pwm_lld_start+0x1bc>)
 800067a:	69d2      	ldr	r2, [r2, #28]
 800067c:	2101      	movs	r1, #1
 800067e:	430a      	orrs	r2, r1
 8000680:	61da      	str	r2, [r3, #28]
      rccResetTIM2();
 8000682:	4b66      	ldr	r3, [pc, #408]	; (800081c <pwm_lld_start+0x1bc>)
 8000684:	4a65      	ldr	r2, [pc, #404]	; (800081c <pwm_lld_start+0x1bc>)
 8000686:	6912      	ldr	r2, [r2, #16]
 8000688:	2101      	movs	r1, #1
 800068a:	430a      	orrs	r2, r1
 800068c:	611a      	str	r2, [r3, #16]
 800068e:	4b63      	ldr	r3, [pc, #396]	; (800081c <pwm_lld_start+0x1bc>)
 8000690:	2200      	movs	r2, #0
 8000692:	611a      	str	r2, [r3, #16]
#if !defined(STM32_TIM2_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM2_NUMBER, STM32_PWM_TIM2_IRQ_PRIORITY);
 8000694:	2103      	movs	r1, #3
 8000696:	200f      	movs	r0, #15
 8000698:	f000 fd0a 	bl	80010b0 <nvicEnableVector>
#endif
#if defined(STM32_TIM2CLK)
      pwmp->clock = STM32_TIM2CLK;
#else
      pwmp->clock = STM32_TIMCLK1;
 800069c:	9b01      	ldr	r3, [sp, #4]
 800069e:	4a60      	ldr	r2, [pc, #384]	; (8000820 <pwm_lld_start+0x1c0>)
 80006a0:	615a      	str	r2, [r3, #20]
#endif
    }
#endif

#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
 80006a2:	9a01      	ldr	r2, [sp, #4]
 80006a4:	4b5f      	ldr	r3, [pc, #380]	; (8000824 <pwm_lld_start+0x1c4>)
 80006a6:	429a      	cmp	r2, r3
 80006a8:	d115      	bne.n	80006d6 <pwm_lld_start+0x76>
      rccEnableTIM3(FALSE);
 80006aa:	4b5c      	ldr	r3, [pc, #368]	; (800081c <pwm_lld_start+0x1bc>)
 80006ac:	4a5b      	ldr	r2, [pc, #364]	; (800081c <pwm_lld_start+0x1bc>)
 80006ae:	69d2      	ldr	r2, [r2, #28]
 80006b0:	2102      	movs	r1, #2
 80006b2:	430a      	orrs	r2, r1
 80006b4:	61da      	str	r2, [r3, #28]
      rccResetTIM3();
 80006b6:	4b59      	ldr	r3, [pc, #356]	; (800081c <pwm_lld_start+0x1bc>)
 80006b8:	4a58      	ldr	r2, [pc, #352]	; (800081c <pwm_lld_start+0x1bc>)
 80006ba:	6912      	ldr	r2, [r2, #16]
 80006bc:	2102      	movs	r1, #2
 80006be:	430a      	orrs	r2, r1
 80006c0:	611a      	str	r2, [r3, #16]
 80006c2:	4b56      	ldr	r3, [pc, #344]	; (800081c <pwm_lld_start+0x1bc>)
 80006c4:	2200      	movs	r2, #0
 80006c6:	611a      	str	r2, [r3, #16]
#if !defined(STM32_TIM3_SUPPRESS_ISR)
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_PWM_TIM3_IRQ_PRIORITY);
 80006c8:	2103      	movs	r1, #3
 80006ca:	2010      	movs	r0, #16
 80006cc:	f000 fcf0 	bl	80010b0 <nvicEnableVector>
#endif
#if defined(STM32_TIM3CLK)
      pwmp->clock = STM32_TIM3CLK;
#else
      pwmp->clock = STM32_TIMCLK1;
 80006d0:	9b01      	ldr	r3, [sp, #4]
 80006d2:	4a53      	ldr	r2, [pc, #332]	; (8000820 <pwm_lld_start+0x1c0>)
 80006d4:	615a      	str	r2, [r3, #20]
    }
#endif

    /* All channels configured in PWM1 mode with preload enabled and will
       stay that way until the driver is stopped.*/
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 80006d6:	9b01      	ldr	r3, [sp, #4]
 80006d8:	699b      	ldr	r3, [r3, #24]
 80006da:	4a53      	ldr	r2, [pc, #332]	; (8000828 <pwm_lld_start+0x1c8>)
 80006dc:	619a      	str	r2, [r3, #24]
                       STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 80006de:	9b01      	ldr	r3, [sp, #4]
 80006e0:	699b      	ldr	r3, [r3, #24]
 80006e2:	4a51      	ldr	r2, [pc, #324]	; (8000828 <pwm_lld_start+0x1c8>)
 80006e4:	61da      	str	r2, [r3, #28]
 80006e6:	e017      	b.n	8000718 <pwm_lld_start+0xb8>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 80006e8:	9b01      	ldr	r3, [sp, #4]
 80006ea:	699b      	ldr	r3, [r3, #24]
 80006ec:	2200      	movs	r2, #0
 80006ee:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 80006f0:	9b01      	ldr	r3, [sp, #4]
 80006f2:	699b      	ldr	r3, [r3, #24]
 80006f4:	2200      	movs	r2, #0
 80006f6:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 80006f8:	9b01      	ldr	r3, [sp, #4]
 80006fa:	699b      	ldr	r3, [r3, #24]
 80006fc:	2200      	movs	r2, #0
 80006fe:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8000700:	9b01      	ldr	r3, [sp, #4]
 8000702:	699b      	ldr	r3, [r3, #24]
 8000704:	2200      	movs	r2, #0
 8000706:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8000708:	9b01      	ldr	r3, [sp, #4]
 800070a:	699b      	ldr	r3, [r3, #24]
 800070c:	2200      	movs	r2, #0
 800070e:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8000710:	9b01      	ldr	r3, [sp, #4]
 8000712:	699b      	ldr	r3, [r3, #24]
 8000714:	2200      	movs	r2, #0
 8000716:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8000718:	9b01      	ldr	r3, [sp, #4]
 800071a:	695a      	ldr	r2, [r3, #20]
 800071c:	9b01      	ldr	r3, [sp, #4]
 800071e:	685b      	ldr	r3, [r3, #4]
 8000720:	681b      	ldr	r3, [r3, #0]
 8000722:	0019      	movs	r1, r3
 8000724:	0010      	movs	r0, r2
 8000726:	f7ff fd53 	bl	80001d0 <__aeabi_uidiv>
 800072a:	0003      	movs	r3, r0
 800072c:	3b01      	subs	r3, #1
 800072e:	9302      	str	r3, [sp, #8]
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 8000730:	9b01      	ldr	r3, [sp, #4]
 8000732:	699b      	ldr	r3, [r3, #24]
 8000734:	9a02      	ldr	r2, [sp, #8]
 8000736:	629a      	str	r2, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8000738:	9b01      	ldr	r3, [sp, #4]
 800073a:	699b      	ldr	r3, [r3, #24]
 800073c:	9a01      	ldr	r2, [sp, #4]
 800073e:	6892      	ldr	r2, [r2, #8]
 8000740:	3a01      	subs	r2, #1
 8000742:	62da      	str	r2, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8000744:	9b01      	ldr	r3, [sp, #4]
 8000746:	699b      	ldr	r3, [r3, #24]
 8000748:	9a01      	ldr	r2, [sp, #4]
 800074a:	6852      	ldr	r2, [r2, #4]
 800074c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800074e:	605a      	str	r2, [r3, #4]

  /* Output enables and polarities setup.*/
  ccer = 0;
 8000750:	2300      	movs	r3, #0
 8000752:	9303      	str	r3, [sp, #12]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8000754:	9b01      	ldr	r3, [sp, #4]
 8000756:	685b      	ldr	r3, [r3, #4]
 8000758:	68db      	ldr	r3, [r3, #12]
 800075a:	220f      	movs	r2, #15
 800075c:	4013      	ands	r3, r2
 800075e:	2b01      	cmp	r3, #1
 8000760:	d005      	beq.n	800076e <pwm_lld_start+0x10e>
 8000762:	2b02      	cmp	r3, #2
 8000764:	d107      	bne.n	8000776 <pwm_lld_start+0x116>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC1P;
 8000766:	9b03      	ldr	r3, [sp, #12]
 8000768:	2202      	movs	r2, #2
 800076a:	4313      	orrs	r3, r2
 800076c:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
 800076e:	9b03      	ldr	r3, [sp, #12]
 8000770:	2201      	movs	r2, #1
 8000772:	4313      	orrs	r3, r2
 8000774:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8000776:	9b01      	ldr	r3, [sp, #4]
 8000778:	685b      	ldr	r3, [r3, #4]
 800077a:	695b      	ldr	r3, [r3, #20]
 800077c:	220f      	movs	r2, #15
 800077e:	4013      	ands	r3, r2
 8000780:	2b01      	cmp	r3, #1
 8000782:	d005      	beq.n	8000790 <pwm_lld_start+0x130>
 8000784:	2b02      	cmp	r3, #2
 8000786:	d107      	bne.n	8000798 <pwm_lld_start+0x138>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 8000788:	9b03      	ldr	r3, [sp, #12]
 800078a:	2220      	movs	r2, #32
 800078c:	4313      	orrs	r3, r2
 800078e:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 8000790:	9b03      	ldr	r3, [sp, #12]
 8000792:	2210      	movs	r2, #16
 8000794:	4313      	orrs	r3, r2
 8000796:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8000798:	9b01      	ldr	r3, [sp, #4]
 800079a:	685b      	ldr	r3, [r3, #4]
 800079c:	69db      	ldr	r3, [r3, #28]
 800079e:	220f      	movs	r2, #15
 80007a0:	4013      	ands	r3, r2
 80007a2:	2b01      	cmp	r3, #1
 80007a4:	d006      	beq.n	80007b4 <pwm_lld_start+0x154>
 80007a6:	2b02      	cmp	r3, #2
 80007a8:	d109      	bne.n	80007be <pwm_lld_start+0x15e>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 80007aa:	9b03      	ldr	r3, [sp, #12]
 80007ac:	2280      	movs	r2, #128	; 0x80
 80007ae:	0092      	lsls	r2, r2, #2
 80007b0:	4313      	orrs	r3, r2
 80007b2:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 80007b4:	9b03      	ldr	r3, [sp, #12]
 80007b6:	2280      	movs	r2, #128	; 0x80
 80007b8:	0052      	lsls	r2, r2, #1
 80007ba:	4313      	orrs	r3, r2
 80007bc:	9303      	str	r3, [sp, #12]
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 80007be:	9b01      	ldr	r3, [sp, #4]
 80007c0:	685b      	ldr	r3, [r3, #4]
 80007c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80007c4:	220f      	movs	r2, #15
 80007c6:	4013      	ands	r3, r2
 80007c8:	2b01      	cmp	r3, #1
 80007ca:	d006      	beq.n	80007da <pwm_lld_start+0x17a>
 80007cc:	2b02      	cmp	r3, #2
 80007ce:	d109      	bne.n	80007e4 <pwm_lld_start+0x184>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 80007d0:	9b03      	ldr	r3, [sp, #12]
 80007d2:	2280      	movs	r2, #128	; 0x80
 80007d4:	0192      	lsls	r2, r2, #6
 80007d6:	4313      	orrs	r3, r2
 80007d8:	9303      	str	r3, [sp, #12]
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 80007da:	9b03      	ldr	r3, [sp, #12]
 80007dc:	2280      	movs	r2, #128	; 0x80
 80007de:	0152      	lsls	r2, r2, #5
 80007e0:	4313      	orrs	r3, r2
 80007e2:	9303      	str	r3, [sp, #12]
      ;
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
 80007e4:	9b01      	ldr	r3, [sp, #4]
 80007e6:	699b      	ldr	r3, [r3, #24]
 80007e8:	9a03      	ldr	r2, [sp, #12]
 80007ea:	621a      	str	r2, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 80007ec:	9b01      	ldr	r3, [sp, #4]
 80007ee:	699b      	ldr	r3, [r3, #24]
 80007f0:	2201      	movs	r2, #1
 80007f2:	615a      	str	r2, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 80007f4:	9b01      	ldr	r3, [sp, #4]
 80007f6:	699b      	ldr	r3, [r3, #24]
 80007f8:	2200      	movs	r2, #0
 80007fa:	611a      	str	r2, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 80007fc:	9b01      	ldr	r3, [sp, #4]
 80007fe:	699b      	ldr	r3, [r3, #24]
 8000800:	9a01      	ldr	r2, [sp, #4]
 8000802:	6852      	ldr	r2, [r2, #4]
 8000804:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8000806:	21ff      	movs	r1, #255	; 0xff
 8000808:	438a      	bics	r2, r1
 800080a:	60da      	str	r2, [r3, #12]
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 800080c:	9b01      	ldr	r3, [sp, #4]
 800080e:	699b      	ldr	r3, [r3, #24]
 8000810:	2285      	movs	r2, #133	; 0x85
 8000812:	601a      	str	r2, [r3, #0]
                     STM32_TIM_CR1_CEN;
}
 8000814:	b005      	add	sp, #20
 8000816:	bd00      	pop	{pc}
 8000818:	200007e0 	.word	0x200007e0
 800081c:	40021000 	.word	0x40021000
 8000820:	02dc6c00 	.word	0x02dc6c00
 8000824:	200007fc 	.word	0x200007fc
 8000828:	00006868 	.word	0x00006868
 800082c:	00000000 	.word	0x00000000

08000830 <pwm_lld_enable_channel>:
 *
 * @notapi
 */
void pwm_lld_enable_channel(PWMDriver *pwmp,
                            pwmchannel_t channel,
                            pwmcnt_t width) {
 8000830:	b084      	sub	sp, #16
 8000832:	9003      	str	r0, [sp, #12]
 8000834:	9201      	str	r2, [sp, #4]
 8000836:	230b      	movs	r3, #11
 8000838:	446b      	add	r3, sp
 800083a:	1c0a      	adds	r2, r1, #0
 800083c:	701a      	strb	r2, [r3, #0]

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
 800083e:	9b03      	ldr	r3, [sp, #12]
 8000840:	699a      	ldr	r2, [r3, #24]
 8000842:	230b      	movs	r3, #11
 8000844:	446b      	add	r3, sp
 8000846:	781b      	ldrb	r3, [r3, #0]
 8000848:	330c      	adds	r3, #12
 800084a:	009b      	lsls	r3, r3, #2
 800084c:	18d3      	adds	r3, r2, r3
 800084e:	3304      	adds	r3, #4
 8000850:	9a01      	ldr	r2, [sp, #4]
 8000852:	601a      	str	r2, [r3, #0]
  if (channel < 4)
    pwmp->tim->CCR[channel] = width;
  else
    pwmp->tim->CCXR[channel - 4] = width;
#endif
}
 8000854:	b004      	add	sp, #16
 8000856:	4770      	bx	lr
	...

08000860 <pwm_lld_enable_periodic_notification>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_enable_periodic_notification(PWMDriver *pwmp) {
 8000860:	b084      	sub	sp, #16
 8000862:	9001      	str	r0, [sp, #4]
  uint32_t dier = pwmp->tim->DIER;
 8000864:	9b01      	ldr	r3, [sp, #4]
 8000866:	699b      	ldr	r3, [r3, #24]
 8000868:	68db      	ldr	r3, [r3, #12]
 800086a:	9303      	str	r3, [sp, #12]

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & STM32_TIM_DIER_UIE) == 0) {
 800086c:	9b03      	ldr	r3, [sp, #12]
 800086e:	2201      	movs	r2, #1
 8000870:	4013      	ands	r3, r2
 8000872:	d10d      	bne.n	8000890 <pwm_lld_enable_periodic_notification+0x30>
    pwmp->tim->DIER = dier | STM32_TIM_DIER_UIE;
 8000874:	9b01      	ldr	r3, [sp, #4]
 8000876:	699b      	ldr	r3, [r3, #24]
 8000878:	9a03      	ldr	r2, [sp, #12]
 800087a:	2101      	movs	r1, #1
 800087c:	430a      	orrs	r2, r1
 800087e:	60da      	str	r2, [r3, #12]
    pwmp->tim->SR &= STM32_TIM_SR_UIF;
 8000880:	9b01      	ldr	r3, [sp, #4]
 8000882:	699b      	ldr	r3, [r3, #24]
 8000884:	9a01      	ldr	r2, [sp, #4]
 8000886:	6992      	ldr	r2, [r2, #24]
 8000888:	6912      	ldr	r2, [r2, #16]
 800088a:	2101      	movs	r1, #1
 800088c:	400a      	ands	r2, r1
 800088e:	611a      	str	r2, [r3, #16]
  }
}
 8000890:	b004      	add	sp, #16
 8000892:	4770      	bx	lr
	...

080008a0 <pwm_lld_enable_channel_notification>:
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @notapi
 */
void pwm_lld_enable_channel_notification(PWMDriver *pwmp,
                                         pwmchannel_t channel) {
 80008a0:	b084      	sub	sp, #16
 80008a2:	9001      	str	r0, [sp, #4]
 80008a4:	000a      	movs	r2, r1
 80008a6:	466b      	mov	r3, sp
 80008a8:	3303      	adds	r3, #3
 80008aa:	701a      	strb	r2, [r3, #0]
  uint32_t dier = pwmp->tim->DIER;
 80008ac:	9b01      	ldr	r3, [sp, #4]
 80008ae:	699b      	ldr	r3, [r3, #24]
 80008b0:	68db      	ldr	r3, [r3, #12]
 80008b2:	9303      	str	r3, [sp, #12]
  osalDbgAssert(channel < 4, "callback not supported");
#endif

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & (2 << channel)) == 0) {
 80008b4:	466b      	mov	r3, sp
 80008b6:	3303      	adds	r3, #3
 80008b8:	781b      	ldrb	r3, [r3, #0]
 80008ba:	2202      	movs	r2, #2
 80008bc:	409a      	lsls	r2, r3
 80008be:	0013      	movs	r3, r2
 80008c0:	001a      	movs	r2, r3
 80008c2:	9b03      	ldr	r3, [sp, #12]
 80008c4:	4013      	ands	r3, r2
 80008c6:	d115      	bne.n	80008f4 <pwm_lld_enable_channel_notification+0x54>
    pwmp->tim->DIER = dier | (2 << channel);
 80008c8:	9b01      	ldr	r3, [sp, #4]
 80008ca:	699b      	ldr	r3, [r3, #24]
 80008cc:	466a      	mov	r2, sp
 80008ce:	3203      	adds	r2, #3
 80008d0:	7812      	ldrb	r2, [r2, #0]
 80008d2:	2102      	movs	r1, #2
 80008d4:	4091      	lsls	r1, r2
 80008d6:	000a      	movs	r2, r1
 80008d8:	0011      	movs	r1, r2
 80008da:	9a03      	ldr	r2, [sp, #12]
 80008dc:	430a      	orrs	r2, r1
 80008de:	60da      	str	r2, [r3, #12]
    pwmp->tim->SR   = ~(2 << channel);
 80008e0:	9b01      	ldr	r3, [sp, #4]
 80008e2:	699b      	ldr	r3, [r3, #24]
 80008e4:	466a      	mov	r2, sp
 80008e6:	3203      	adds	r2, #3
 80008e8:	7812      	ldrb	r2, [r2, #0]
 80008ea:	2102      	movs	r1, #2
 80008ec:	4091      	lsls	r1, r2
 80008ee:	000a      	movs	r2, r1
 80008f0:	43d2      	mvns	r2, r2
 80008f2:	611a      	str	r2, [r3, #16]
  }
}
 80008f4:	b004      	add	sp, #16
 80008f6:	4770      	bx	lr
	...

08000900 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8000900:	b500      	push	{lr}
 8000902:	b085      	sub	sp, #20
 8000904:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8000906:	9b01      	ldr	r3, [sp, #4]
 8000908:	699b      	ldr	r3, [r3, #24]
 800090a:	691b      	ldr	r3, [r3, #16]
 800090c:	9303      	str	r3, [sp, #12]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800090e:	9b01      	ldr	r3, [sp, #4]
 8000910:	699b      	ldr	r3, [r3, #24]
 8000912:	68db      	ldr	r3, [r3, #12]
 8000914:	22ff      	movs	r2, #255	; 0xff
 8000916:	401a      	ands	r2, r3
 8000918:	9b03      	ldr	r3, [sp, #12]
 800091a:	4013      	ands	r3, r2
 800091c:	9303      	str	r3, [sp, #12]
  pwmp->tim->SR = ~sr;
 800091e:	9b01      	ldr	r3, [sp, #4]
 8000920:	699b      	ldr	r3, [r3, #24]
 8000922:	9a03      	ldr	r2, [sp, #12]
 8000924:	43d2      	mvns	r2, r2
 8000926:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000928:	9b03      	ldr	r3, [sp, #12]
 800092a:	2202      	movs	r2, #2
 800092c:	4013      	ands	r3, r2
 800092e:	d00a      	beq.n	8000946 <pwm_lld_serve_interrupt+0x46>
      (pwmp->config->channels[0].callback != NULL))
 8000930:	9b01      	ldr	r3, [sp, #4]
 8000932:	685b      	ldr	r3, [r3, #4]
 8000934:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000936:	2b00      	cmp	r3, #0
 8000938:	d005      	beq.n	8000946 <pwm_lld_serve_interrupt+0x46>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 800093a:	9b01      	ldr	r3, [sp, #4]
 800093c:	685b      	ldr	r3, [r3, #4]
 800093e:	691b      	ldr	r3, [r3, #16]
 8000940:	9a01      	ldr	r2, [sp, #4]
 8000942:	0010      	movs	r0, r2
 8000944:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8000946:	9b03      	ldr	r3, [sp, #12]
 8000948:	2204      	movs	r2, #4
 800094a:	4013      	ands	r3, r2
 800094c:	d00a      	beq.n	8000964 <pwm_lld_serve_interrupt+0x64>
      (pwmp->config->channels[1].callback != NULL))
 800094e:	9b01      	ldr	r3, [sp, #4]
 8000950:	685b      	ldr	r3, [r3, #4]
 8000952:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8000954:	2b00      	cmp	r3, #0
 8000956:	d005      	beq.n	8000964 <pwm_lld_serve_interrupt+0x64>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 8000958:	9b01      	ldr	r3, [sp, #4]
 800095a:	685b      	ldr	r3, [r3, #4]
 800095c:	699b      	ldr	r3, [r3, #24]
 800095e:	9a01      	ldr	r2, [sp, #4]
 8000960:	0010      	movs	r0, r2
 8000962:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8000964:	9b03      	ldr	r3, [sp, #12]
 8000966:	2208      	movs	r2, #8
 8000968:	4013      	ands	r3, r2
 800096a:	d00a      	beq.n	8000982 <pwm_lld_serve_interrupt+0x82>
      (pwmp->config->channels[2].callback != NULL))
 800096c:	9b01      	ldr	r3, [sp, #4]
 800096e:	685b      	ldr	r3, [r3, #4]
 8000970:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8000972:	2b00      	cmp	r3, #0
 8000974:	d005      	beq.n	8000982 <pwm_lld_serve_interrupt+0x82>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8000976:	9b01      	ldr	r3, [sp, #4]
 8000978:	685b      	ldr	r3, [r3, #4]
 800097a:	6a1b      	ldr	r3, [r3, #32]
 800097c:	9a01      	ldr	r2, [sp, #4]
 800097e:	0010      	movs	r0, r2
 8000980:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8000982:	9b03      	ldr	r3, [sp, #12]
 8000984:	2210      	movs	r2, #16
 8000986:	4013      	ands	r3, r2
 8000988:	d00a      	beq.n	80009a0 <pwm_lld_serve_interrupt+0xa0>
      (pwmp->config->channels[3].callback != NULL))
 800098a:	9b01      	ldr	r3, [sp, #4]
 800098c:	685b      	ldr	r3, [r3, #4]
 800098e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8000990:	2b00      	cmp	r3, #0
 8000992:	d005      	beq.n	80009a0 <pwm_lld_serve_interrupt+0xa0>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 8000994:	9b01      	ldr	r3, [sp, #4]
 8000996:	685b      	ldr	r3, [r3, #4]
 8000998:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800099a:	9a01      	ldr	r2, [sp, #4]
 800099c:	0010      	movs	r0, r2
 800099e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 80009a0:	9b03      	ldr	r3, [sp, #12]
 80009a2:	2201      	movs	r2, #1
 80009a4:	4013      	ands	r3, r2
 80009a6:	d00a      	beq.n	80009be <pwm_lld_serve_interrupt+0xbe>
 80009a8:	9b01      	ldr	r3, [sp, #4]
 80009aa:	685b      	ldr	r3, [r3, #4]
 80009ac:	689b      	ldr	r3, [r3, #8]
 80009ae:	2b00      	cmp	r3, #0
 80009b0:	d005      	beq.n	80009be <pwm_lld_serve_interrupt+0xbe>
    pwmp->config->callback(pwmp);
 80009b2:	9b01      	ldr	r3, [sp, #4]
 80009b4:	685b      	ldr	r3, [r3, #4]
 80009b6:	689b      	ldr	r3, [r3, #8]
 80009b8:	9a01      	ldr	r2, [sp, #4]
 80009ba:	0010      	movs	r0, r2
 80009bc:	4798      	blx	r3
}
 80009be:	b005      	add	sp, #20
 80009c0:	bd00      	pop	{pc}
 80009c2:	46c0      	nop			; (mov r8, r8)
	...

080009d0 <port_lock.lto_priv.136>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80009d0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80009d2:	4770      	bx	lr
	...

080009e0 <port_unlock.lto_priv.134>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009e0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80009e2:	4770      	bx	lr
	...

080009f0 <port_lock_from_isr>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80009f0:	b510      	push	{r4, lr}

  port_lock();
 80009f2:	f7ff ffed 	bl	80009d0 <port_lock.lto_priv.136>
}
 80009f6:	bd10      	pop	{r4, pc}
	...

08000a00 <port_unlock_from_isr>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000a00:	b510      	push	{r4, lr}

  port_unlock();
 8000a02:	f7ff ffed 	bl	80009e0 <port_unlock.lto_priv.134>
}
 8000a06:	bd10      	pop	{r4, pc}
	...

08000a10 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000a10:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8000a12:	f7ff ffed 	bl	80009f0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000a16:	bd10      	pop	{r4, pc}
	...

08000a20 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000a20:	b510      	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000a22:	f7ff ffed 	bl	8000a00 <port_unlock_from_isr>
}
 8000a26:	bd10      	pop	{r4, pc}
	...

08000a30 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8000a30:	b082      	sub	sp, #8
 8000a32:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000a34:	9b01      	ldr	r3, [sp, #4]
 8000a36:	695a      	ldr	r2, [r3, #20]
 8000a38:	9b01      	ldr	r3, [sp, #4]
 8000a3a:	699b      	ldr	r3, [r3, #24]
 8000a3c:	429a      	cmp	r2, r3
 8000a3e:	d105      	bne.n	8000a4c <chOQIsEmptyI+0x1c>
 8000a40:	9b01      	ldr	r3, [sp, #4]
 8000a42:	689b      	ldr	r3, [r3, #8]
 8000a44:	2b00      	cmp	r3, #0
 8000a46:	d001      	beq.n	8000a4c <chOQIsEmptyI+0x1c>
 8000a48:	2301      	movs	r3, #1
 8000a4a:	e000      	b.n	8000a4e <chOQIsEmptyI+0x1e>
 8000a4c:	2300      	movs	r3, #0
 8000a4e:	1c1a      	adds	r2, r3, #0
 8000a50:	2301      	movs	r3, #1
 8000a52:	4013      	ands	r3, r2
 8000a54:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8000a56:	0018      	movs	r0, r3
 8000a58:	b002      	add	sp, #8
 8000a5a:	4770      	bx	lr
 8000a5c:	0000      	movs	r0, r0
	...

08000a60 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000a60:	b510      	push	{r4, lr}

  chSysLockFromISR();
 8000a62:	f7ff ffd5 	bl	8000a10 <chSysLockFromISR>
}
 8000a66:	bd10      	pop	{r4, pc}
	...

08000a70 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000a70:	b510      	push	{r4, lr}

  chSysUnlockFromISR();
 8000a72:	f7ff ffd5 	bl	8000a20 <chSysUnlockFromISR>
}
 8000a76:	bd10      	pop	{r4, pc}
	...

08000a80 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8000a80:	b500      	push	{lr}
 8000a82:	b083      	sub	sp, #12
 8000a84:	9001      	str	r0, [sp, #4]
 8000a86:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8000a88:	9a00      	ldr	r2, [sp, #0]
 8000a8a:	9b01      	ldr	r3, [sp, #4]
 8000a8c:	0011      	movs	r1, r2
 8000a8e:	0018      	movs	r0, r3
 8000a90:	f001 f93e 	bl	8001d10 <chEvtBroadcastFlagsI>
}
 8000a94:	b003      	add	sp, #12
 8000a96:	bd00      	pop	{pc}
	...

08000aa0 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 8000aa0:	b500      	push	{lr}
 8000aa2:	b085      	sub	sp, #20
 8000aa4:	9001      	str	r0, [sp, #4]
 8000aa6:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 8000aa8:	2300      	movs	r3, #0
 8000aaa:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 8000aac:	9b00      	ldr	r3, [sp, #0]
 8000aae:	2208      	movs	r2, #8
 8000ab0:	4013      	ands	r3, r2
 8000ab2:	d003      	beq.n	8000abc <set_error+0x1c>
    sts |= SD_OVERRUN_ERROR;
 8000ab4:	9b03      	ldr	r3, [sp, #12]
 8000ab6:	2280      	movs	r2, #128	; 0x80
 8000ab8:	4313      	orrs	r3, r2
 8000aba:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 8000abc:	9b00      	ldr	r3, [sp, #0]
 8000abe:	2201      	movs	r2, #1
 8000ac0:	4013      	ands	r3, r2
 8000ac2:	d003      	beq.n	8000acc <set_error+0x2c>
    sts |= SD_PARITY_ERROR;
 8000ac4:	9b03      	ldr	r3, [sp, #12]
 8000ac6:	2220      	movs	r2, #32
 8000ac8:	4313      	orrs	r3, r2
 8000aca:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 8000acc:	9b00      	ldr	r3, [sp, #0]
 8000ace:	2202      	movs	r2, #2
 8000ad0:	4013      	ands	r3, r2
 8000ad2:	d003      	beq.n	8000adc <set_error+0x3c>
    sts |= SD_FRAMING_ERROR;
 8000ad4:	9b03      	ldr	r3, [sp, #12]
 8000ad6:	2240      	movs	r2, #64	; 0x40
 8000ad8:	4313      	orrs	r3, r2
 8000ada:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 8000adc:	9b00      	ldr	r3, [sp, #0]
 8000ade:	2204      	movs	r2, #4
 8000ae0:	4013      	ands	r3, r2
 8000ae2:	d004      	beq.n	8000aee <set_error+0x4e>
    sts |= SD_NOISE_ERROR;
 8000ae4:	9b03      	ldr	r3, [sp, #12]
 8000ae6:	2280      	movs	r2, #128	; 0x80
 8000ae8:	0052      	lsls	r2, r2, #1
 8000aea:	4313      	orrs	r3, r2
 8000aec:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 8000aee:	f7ff ffb7 	bl	8000a60 <osalSysLockFromISR>
  chnAddFlagsI(sdp, sts);
 8000af2:	9b01      	ldr	r3, [sp, #4]
 8000af4:	3304      	adds	r3, #4
 8000af6:	9a03      	ldr	r2, [sp, #12]
 8000af8:	0011      	movs	r1, r2
 8000afa:	0018      	movs	r0, r3
 8000afc:	f7ff ffc0 	bl	8000a80 <osalEventBroadcastFlagsI>
  osalSysUnlockFromISR();
 8000b00:	f7ff ffb6 	bl	8000a70 <osalSysUnlockFromISR>
}
 8000b04:	b005      	add	sp, #20
 8000b06:	bd00      	pop	{pc}
	...

08000b10 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000b10:	b500      	push	{lr}
 8000b12:	b087      	sub	sp, #28
 8000b14:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8000b16:	9b01      	ldr	r3, [sp, #4]
 8000b18:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8000b1a:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 8000b1c:	9b05      	ldr	r3, [sp, #20]
 8000b1e:	681b      	ldr	r3, [r3, #0]
 8000b20:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000b22:	9b05      	ldr	r3, [sp, #20]
 8000b24:	69db      	ldr	r3, [r3, #28]
 8000b26:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 8000b28:	9b05      	ldr	r3, [sp, #20]
 8000b2a:	9a03      	ldr	r2, [sp, #12]
 8000b2c:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000b2e:	9b03      	ldr	r3, [sp, #12]
 8000b30:	220f      	movs	r2, #15
 8000b32:	4013      	ands	r3, r2
 8000b34:	d005      	beq.n	8000b42 <serve_interrupt+0x32>
    set_error(sdp, isr);
 8000b36:	9a03      	ldr	r2, [sp, #12]
 8000b38:	9b01      	ldr	r3, [sp, #4]
 8000b3a:	0011      	movs	r1, r2
 8000b3c:	0018      	movs	r0, r3
 8000b3e:	f7ff ffaf 	bl	8000aa0 <set_error>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000b42:	9a03      	ldr	r2, [sp, #12]
 8000b44:	2380      	movs	r3, #128	; 0x80
 8000b46:	005b      	lsls	r3, r3, #1
 8000b48:	4013      	ands	r3, r2
 8000b4a:	d00b      	beq.n	8000b64 <serve_interrupt+0x54>
    osalSysLockFromISR();
 8000b4c:	f7ff ff88 	bl	8000a60 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8000b50:	9b01      	ldr	r3, [sp, #4]
 8000b52:	1d1a      	adds	r2, r3, #4
 8000b54:	2380      	movs	r3, #128	; 0x80
 8000b56:	009b      	lsls	r3, r3, #2
 8000b58:	0019      	movs	r1, r3
 8000b5a:	0010      	movs	r0, r2
 8000b5c:	f7ff ff90 	bl	8000a80 <osalEventBroadcastFlagsI>
    osalSysUnlockFromISR();
 8000b60:	f7ff ff86 	bl	8000a70 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000b64:	9b03      	ldr	r3, [sp, #12]
 8000b66:	2220      	movs	r2, #32
 8000b68:	4013      	ands	r3, r2
 8000b6a:	d00c      	beq.n	8000b86 <serve_interrupt+0x76>
    osalSysLockFromISR();
 8000b6c:	f7ff ff78 	bl	8000a60 <osalSysLockFromISR>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000b70:	9b05      	ldr	r3, [sp, #20]
 8000b72:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000b74:	b29b      	uxth	r3, r3
 8000b76:	b2da      	uxtb	r2, r3
 8000b78:	9b01      	ldr	r3, [sp, #4]
 8000b7a:	0011      	movs	r1, r2
 8000b7c:	0018      	movs	r0, r3
 8000b7e:	f000 fa6f 	bl	8001060 <sdIncomingDataI>
    osalSysUnlockFromISR();
 8000b82:	f7ff ff75 	bl	8000a70 <osalSysUnlockFromISR>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000b86:	9b04      	ldr	r3, [sp, #16]
 8000b88:	2280      	movs	r2, #128	; 0x80
 8000b8a:	4013      	ands	r3, r2
 8000b8c:	d023      	beq.n	8000bd6 <serve_interrupt+0xc6>
 8000b8e:	9b03      	ldr	r3, [sp, #12]
 8000b90:	2280      	movs	r2, #128	; 0x80
 8000b92:	4013      	ands	r3, r2
 8000b94:	d01f      	beq.n	8000bd6 <serve_interrupt+0xc6>
    msg_t b;
    osalSysLockFromISR();
 8000b96:	f7ff ff63 	bl	8000a60 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
 8000b9a:	9b01      	ldr	r3, [sp, #4]
 8000b9c:	3330      	adds	r3, #48	; 0x30
 8000b9e:	0018      	movs	r0, r3
 8000ba0:	f000 feb6 	bl	8001910 <chOQGetI>
 8000ba4:	0003      	movs	r3, r0
 8000ba6:	9302      	str	r3, [sp, #8]
    if (b < Q_OK) {
 8000ba8:	9b02      	ldr	r3, [sp, #8]
 8000baa:	2b00      	cmp	r3, #0
 8000bac:	da0d      	bge.n	8000bca <serve_interrupt+0xba>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000bae:	9b01      	ldr	r3, [sp, #4]
 8000bb0:	3304      	adds	r3, #4
 8000bb2:	2108      	movs	r1, #8
 8000bb4:	0018      	movs	r0, r3
 8000bb6:	f7ff ff63 	bl	8000a80 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000bba:	9b04      	ldr	r3, [sp, #16]
 8000bbc:	22c0      	movs	r2, #192	; 0xc0
 8000bbe:	4393      	bics	r3, r2
 8000bc0:	2240      	movs	r2, #64	; 0x40
 8000bc2:	431a      	orrs	r2, r3
 8000bc4:	9b05      	ldr	r3, [sp, #20]
 8000bc6:	601a      	str	r2, [r3, #0]
 8000bc8:	e003      	b.n	8000bd2 <serve_interrupt+0xc2>
    }
    else
      u->TDR = b;
 8000bca:	9b02      	ldr	r3, [sp, #8]
 8000bcc:	b29a      	uxth	r2, r3
 8000bce:	9b05      	ldr	r3, [sp, #20]
 8000bd0:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 8000bd2:	f7ff ff4d 	bl	8000a70 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000bd6:	9b03      	ldr	r3, [sp, #12]
 8000bd8:	2240      	movs	r2, #64	; 0x40
 8000bda:	4013      	ands	r3, r2
 8000bdc:	d016      	beq.n	8000c0c <serve_interrupt+0xfc>
    osalSysLockFromISR();
 8000bde:	f7ff ff3f 	bl	8000a60 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
 8000be2:	9b01      	ldr	r3, [sp, #4]
 8000be4:	3330      	adds	r3, #48	; 0x30
 8000be6:	0018      	movs	r0, r3
 8000be8:	f7ff ff22 	bl	8000a30 <chOQIsEmptyI>
 8000bec:	1e03      	subs	r3, r0, #0
 8000bee:	d005      	beq.n	8000bfc <serve_interrupt+0xec>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000bf0:	9b01      	ldr	r3, [sp, #4]
 8000bf2:	3304      	adds	r3, #4
 8000bf4:	2110      	movs	r1, #16
 8000bf6:	0018      	movs	r0, r3
 8000bf8:	f7ff ff42 	bl	8000a80 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000bfc:	9b04      	ldr	r3, [sp, #16]
 8000bfe:	2240      	movs	r2, #64	; 0x40
 8000c00:	4393      	bics	r3, r2
 8000c02:	001a      	movs	r2, r3
 8000c04:	9b05      	ldr	r3, [sp, #20]
 8000c06:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8000c08:	f7ff ff32 	bl	8000a70 <osalSysUnlockFromISR>
  }
}
 8000c0c:	b007      	add	sp, #28
 8000c0e:	bd00      	pop	{pc}

08000c10 <notify2>:
  USART1->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 8000c10:	b082      	sub	sp, #8
 8000c12:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8000c14:	4b03      	ldr	r3, [pc, #12]	; (8000c24 <notify2+0x14>)
 8000c16:	4a03      	ldr	r2, [pc, #12]	; (8000c24 <notify2+0x14>)
 8000c18:	6812      	ldr	r2, [r2, #0]
 8000c1a:	2180      	movs	r1, #128	; 0x80
 8000c1c:	430a      	orrs	r2, r1
 8000c1e:	601a      	str	r2, [r3, #0]
}
 8000c20:	b002      	add	sp, #8
 8000c22:	4770      	bx	lr
 8000c24:	40004400 	.word	0x40004400
	...

08000c30 <VectorB0>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000c30:	b500      	push	{lr}
 8000c32:	b083      	sub	sp, #12
 8000c34:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000c36:	9301      	str	r3, [sp, #4]

  serve_interrupt(&SD2);
 8000c38:	4b04      	ldr	r3, [pc, #16]	; (8000c4c <VectorB0+0x1c>)
 8000c3a:	0018      	movs	r0, r3
 8000c3c:	f7ff ff68 	bl	8000b10 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8000c40:	9b01      	ldr	r3, [sp, #4]
 8000c42:	0018      	movs	r0, r3
 8000c44:	f000 ffb4 	bl	8001bb0 <_port_irq_epilogue>
}
 8000c48:	b003      	add	sp, #12
 8000c4a:	bd00      	pop	{pc}
 8000c4c:	20000818 	.word	0x20000818

08000c50 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8000c50:	b510      	push	{r4, lr}
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8000c52:	4a08      	ldr	r2, [pc, #32]	; (8000c74 <sd_lld_init+0x24>)
 8000c54:	4b08      	ldr	r3, [pc, #32]	; (8000c78 <sd_lld_init+0x28>)
 8000c56:	2100      	movs	r1, #0
 8000c58:	0018      	movs	r0, r3
 8000c5a:	f000 f9d1 	bl	8001000 <sdObjectInit>
  SD2.usart = USART2;
 8000c5e:	4b06      	ldr	r3, [pc, #24]	; (8000c78 <sd_lld_init+0x28>)
 8000c60:	4a06      	ldr	r2, [pc, #24]	; (8000c7c <sd_lld_init+0x2c>)
 8000c62:	675a      	str	r2, [r3, #116]	; 0x74
  SD2.clock = STM32_USART2CLK;
 8000c64:	4b04      	ldr	r3, [pc, #16]	; (8000c78 <sd_lld_init+0x28>)
 8000c66:	4a06      	ldr	r2, [pc, #24]	; (8000c80 <sd_lld_init+0x30>)
 8000c68:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_USART2_NUMBER)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 8000c6a:	2103      	movs	r1, #3
 8000c6c:	201c      	movs	r0, #28
 8000c6e:	f000 fa1f 	bl	80010b0 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8000c72:	bd10      	pop	{r4, pc}
 8000c74:	08000c11 	.word	0x08000c11
 8000c78:	20000818 	.word	0x20000818
 8000c7c:	40004400 	.word	0x40004400
 8000c80:	02dc6c00 	.word	0x02dc6c00
	...

08000c90 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8000c90:	b510      	push	{r4, lr}

  stm32_clock_init();
 8000c92:	f000 fadd 	bl	8001250 <stm32_clock_init>
}
 8000c96:	bd10      	pop	{r4, pc}
	...

08000ca0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8000ca0:	4770      	bx	lr
 8000ca2:	46c0      	nop			; (mov r8, r8)
	...

08000cb0 <port_lock.lto_priv.142>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cb0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000cb2:	4770      	bx	lr
	...

08000cc0 <port_unlock.lto_priv.139>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000cc0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000cc2:	4770      	bx	lr
	...

08000cd0 <chSysLock.lto_priv.154>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8000cd0:	b510      	push	{r4, lr}

  port_lock();
 8000cd2:	f7ff ffed 	bl	8000cb0 <port_lock.lto_priv.142>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8000cd6:	bd10      	pop	{r4, pc}
	...

08000ce0 <chSysUnlock.lto_priv.152>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000ce0:	b510      	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8000ce2:	f7ff ffed 	bl	8000cc0 <port_unlock.lto_priv.139>
}
 8000ce6:	bd10      	pop	{r4, pc}
	...

08000cf0 <osalSysLock.lto_priv.150>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000cf0:	b510      	push	{r4, lr}

  chSysLock();
 8000cf2:	f7ff ffed 	bl	8000cd0 <chSysLock.lto_priv.154>
}
 8000cf6:	bd10      	pop	{r4, pc}
	...

08000d00 <osalSysUnlock.lto_priv.147>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8000d00:	b510      	push	{r4, lr}

  chSysUnlock();
 8000d02:	f7ff ffed 	bl	8000ce0 <chSysUnlock.lto_priv.152>
}
 8000d06:	bd10      	pop	{r4, pc}
	...

08000d10 <pwmInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void pwmInit(void) {
 8000d10:	b510      	push	{r4, lr}

  pwm_lld_init();
 8000d12:	f7ff fc85 	bl	8000620 <pwm_lld_init>
}
 8000d16:	bd10      	pop	{r4, pc}
	...

08000d20 <pwmObjectInit>:
 *
 * @param[out] pwmp     pointer to a @p PWMDriver object
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {
 8000d20:	b082      	sub	sp, #8
 8000d22:	9001      	str	r0, [sp, #4]

  pwmp->state    = PWM_STOP;
 8000d24:	9b01      	ldr	r3, [sp, #4]
 8000d26:	2201      	movs	r2, #1
 8000d28:	701a      	strb	r2, [r3, #0]
  pwmp->config   = NULL;
 8000d2a:	9b01      	ldr	r3, [sp, #4]
 8000d2c:	2200      	movs	r2, #0
 8000d2e:	605a      	str	r2, [r3, #4]
  pwmp->enabled  = 0;
 8000d30:	9b01      	ldr	r3, [sp, #4]
 8000d32:	2200      	movs	r2, #0
 8000d34:	60da      	str	r2, [r3, #12]
  pwmp->channels = 0;
 8000d36:	9b01      	ldr	r3, [sp, #4]
 8000d38:	2200      	movs	r2, #0
 8000d3a:	741a      	strb	r2, [r3, #16]
#if defined(PWM_DRIVER_EXT_INIT_HOOK)
  PWM_DRIVER_EXT_INIT_HOOK(pwmp);
#endif
}
 8000d3c:	b002      	add	sp, #8
 8000d3e:	4770      	bx	lr

08000d40 <pwmStart>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] config    pointer to a @p PWMConfig object
 *
 * @api
 */
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8000d40:	b500      	push	{lr}
 8000d42:	b083      	sub	sp, #12
 8000d44:	9001      	str	r0, [sp, #4]
 8000d46:	9100      	str	r1, [sp, #0]

  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
 8000d48:	f7ff ffd2 	bl	8000cf0 <osalSysLock.lto_priv.150>
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
 8000d4c:	9b01      	ldr	r3, [sp, #4]
 8000d4e:	9a00      	ldr	r2, [sp, #0]
 8000d50:	605a      	str	r2, [r3, #4]
  pwmp->period = config->period;
 8000d52:	9b00      	ldr	r3, [sp, #0]
 8000d54:	685a      	ldr	r2, [r3, #4]
 8000d56:	9b01      	ldr	r3, [sp, #4]
 8000d58:	609a      	str	r2, [r3, #8]
  pwm_lld_start(pwmp);
 8000d5a:	9b01      	ldr	r3, [sp, #4]
 8000d5c:	0018      	movs	r0, r3
 8000d5e:	f7ff fc7f 	bl	8000660 <pwm_lld_start>
  pwmp->enabled = 0;
 8000d62:	9b01      	ldr	r3, [sp, #4]
 8000d64:	2200      	movs	r2, #0
 8000d66:	60da      	str	r2, [r3, #12]
  pwmp->state = PWM_READY;
 8000d68:	9b01      	ldr	r3, [sp, #4]
 8000d6a:	2202      	movs	r2, #2
 8000d6c:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8000d6e:	f7ff ffc7 	bl	8000d00 <osalSysUnlock.lto_priv.147>
}
 8000d72:	b003      	add	sp, #12
 8000d74:	bd00      	pop	{pc}
 8000d76:	46c0      	nop			; (mov r8, r8)
	...

08000d80 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8000d80:	b500      	push	{lr}
 8000d82:	b085      	sub	sp, #20
 8000d84:	9003      	str	r0, [sp, #12]
 8000d86:	9201      	str	r2, [sp, #4]
 8000d88:	230b      	movs	r3, #11
 8000d8a:	446b      	add	r3, sp
 8000d8c:	1c0a      	adds	r2, r1, #0
 8000d8e:	701a      	strb	r2, [r3, #0]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));

  osalSysLock();
 8000d90:	f7ff ffae 	bl	8000cf0 <osalSysLock.lto_priv.150>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 8000d94:	9b03      	ldr	r3, [sp, #12]
 8000d96:	68da      	ldr	r2, [r3, #12]
 8000d98:	230b      	movs	r3, #11
 8000d9a:	446b      	add	r3, sp
 8000d9c:	781b      	ldrb	r3, [r3, #0]
 8000d9e:	2101      	movs	r1, #1
 8000da0:	4099      	lsls	r1, r3
 8000da2:	000b      	movs	r3, r1
 8000da4:	431a      	orrs	r2, r3
 8000da6:	9b03      	ldr	r3, [sp, #12]
 8000da8:	60da      	str	r2, [r3, #12]
 8000daa:	9a01      	ldr	r2, [sp, #4]
 8000dac:	230b      	movs	r3, #11
 8000dae:	446b      	add	r3, sp
 8000db0:	7819      	ldrb	r1, [r3, #0]
 8000db2:	9b03      	ldr	r3, [sp, #12]
 8000db4:	0018      	movs	r0, r3
 8000db6:	f7ff fd3b 	bl	8000830 <pwm_lld_enable_channel>

  osalSysUnlock();
 8000dba:	f7ff ffa1 	bl	8000d00 <osalSysUnlock.lto_priv.147>
}
 8000dbe:	b005      	add	sp, #20
 8000dc0:	bd00      	pop	{pc}
 8000dc2:	46c0      	nop			; (mov r8, r8)
	...

08000dd0 <pwmEnablePeriodicNotification>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmEnablePeriodicNotification(PWMDriver *pwmp) {
 8000dd0:	b500      	push	{lr}
 8000dd2:	b083      	sub	sp, #12
 8000dd4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(pwmp != NULL);

  osalSysLock();
 8000dd6:	f7ff ff8b 	bl	8000cf0 <osalSysLock.lto_priv.150>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
  osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");

  pwmEnablePeriodicNotificationI(pwmp);
 8000dda:	9b01      	ldr	r3, [sp, #4]
 8000ddc:	0018      	movs	r0, r3
 8000dde:	f7ff fd3f 	bl	8000860 <pwm_lld_enable_periodic_notification>

  osalSysUnlock();
 8000de2:	f7ff ff8d 	bl	8000d00 <osalSysUnlock.lto_priv.147>
}
 8000de6:	b003      	add	sp, #12
 8000de8:	bd00      	pop	{pc}
 8000dea:	46c0      	nop			; (mov r8, r8)
 8000dec:	0000      	movs	r0, r0
	...

08000df0 <pwmEnableChannelNotification>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @api
 */
void pwmEnableChannelNotification(PWMDriver *pwmp, pwmchannel_t channel) {
 8000df0:	b500      	push	{lr}
 8000df2:	b083      	sub	sp, #12
 8000df4:	9001      	str	r0, [sp, #4]
 8000df6:	000a      	movs	r2, r1
 8000df8:	466b      	mov	r3, sp
 8000dfa:	3303      	adds	r3, #3
 8000dfc:	701a      	strb	r2, [r3, #0]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));

  osalSysLock();
 8000dfe:	f7ff ff77 	bl	8000cf0 <osalSysLock.lto_priv.150>
  osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
                "channel not enabled");
  osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
                "undefined channel callback");

  pwmEnableChannelNotificationI(pwmp, channel);
 8000e02:	466b      	mov	r3, sp
 8000e04:	3303      	adds	r3, #3
 8000e06:	781a      	ldrb	r2, [r3, #0]
 8000e08:	9b01      	ldr	r3, [sp, #4]
 8000e0a:	0011      	movs	r1, r2
 8000e0c:	0018      	movs	r0, r3
 8000e0e:	f7ff fd47 	bl	80008a0 <pwm_lld_enable_channel_notification>

  osalSysUnlock();
 8000e12:	f7ff ff75 	bl	8000d00 <osalSysUnlock.lto_priv.147>
}
 8000e16:	b003      	add	sp, #12
 8000e18:	bd00      	pop	{pc}
 8000e1a:	46c0      	nop			; (mov r8, r8)
 8000e1c:	0000      	movs	r0, r0
	...

08000e20 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8000e20:	b082      	sub	sp, #8
 8000e22:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8000e24:	9b01      	ldr	r3, [sp, #4]
 8000e26:	9a01      	ldr	r2, [sp, #4]
 8000e28:	601a      	str	r2, [r3, #0]
}
 8000e2a:	b002      	add	sp, #8
 8000e2c:	4770      	bx	lr
 8000e2e:	46c0      	nop			; (mov r8, r8)

08000e30 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8000e30:	b082      	sub	sp, #8
 8000e32:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000e34:	9b01      	ldr	r3, [sp, #4]
 8000e36:	689b      	ldr	r3, [r3, #8]
 8000e38:	425a      	negs	r2, r3
 8000e3a:	4153      	adcs	r3, r2
 8000e3c:	b2db      	uxtb	r3, r3
}
 8000e3e:	0018      	movs	r0, r3
 8000e40:	b002      	add	sp, #8
 8000e42:	4770      	bx	lr
	...

08000e50 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8000e50:	b500      	push	{lr}
 8000e52:	b083      	sub	sp, #12
 8000e54:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8000e56:	9b01      	ldr	r3, [sp, #4]
 8000e58:	0018      	movs	r0, r3
 8000e5a:	f7ff ffe1 	bl	8000e20 <chEvtObjectInit>
}
 8000e5e:	b003      	add	sp, #12
 8000e60:	bd00      	pop	{pc}
 8000e62:	46c0      	nop			; (mov r8, r8)
	...

08000e70 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8000e70:	b500      	push	{lr}
 8000e72:	b083      	sub	sp, #12
 8000e74:	9001      	str	r0, [sp, #4]
 8000e76:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8000e78:	9a00      	ldr	r2, [sp, #0]
 8000e7a:	9b01      	ldr	r3, [sp, #4]
 8000e7c:	0011      	movs	r1, r2
 8000e7e:	0018      	movs	r0, r3
 8000e80:	f000 ff46 	bl	8001d10 <chEvtBroadcastFlagsI>
}
 8000e84:	b003      	add	sp, #12
 8000e86:	bd00      	pop	{pc}
	...

08000e90 <write.lto_priv.58>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8000e90:	b500      	push	{lr}
 8000e92:	b085      	sub	sp, #20
 8000e94:	9003      	str	r0, [sp, #12]
 8000e96:	9102      	str	r1, [sp, #8]
 8000e98:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000e9a:	9b03      	ldr	r3, [sp, #12]
 8000e9c:	3330      	adds	r3, #48	; 0x30
 8000e9e:	0018      	movs	r0, r3
 8000ea0:	2301      	movs	r3, #1
 8000ea2:	425b      	negs	r3, r3
 8000ea4:	9a01      	ldr	r2, [sp, #4]
 8000ea6:	9902      	ldr	r1, [sp, #8]
 8000ea8:	f000 fd62 	bl	8001970 <chOQWriteTimeout>
 8000eac:	0003      	movs	r3, r0
                        n, TIME_INFINITE);
}
 8000eae:	0018      	movs	r0, r3
 8000eb0:	b005      	add	sp, #20
 8000eb2:	bd00      	pop	{pc}
	...

08000ec0 <read.lto_priv.59>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8000ec0:	b500      	push	{lr}
 8000ec2:	b085      	sub	sp, #20
 8000ec4:	9003      	str	r0, [sp, #12]
 8000ec6:	9102      	str	r1, [sp, #8]
 8000ec8:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000eca:	9b03      	ldr	r3, [sp, #12]
 8000ecc:	330c      	adds	r3, #12
 8000ece:	0018      	movs	r0, r3
 8000ed0:	2301      	movs	r3, #1
 8000ed2:	425b      	negs	r3, r3
 8000ed4:	9a01      	ldr	r2, [sp, #4]
 8000ed6:	9902      	ldr	r1, [sp, #8]
 8000ed8:	f000 fc52 	bl	8001780 <chIQReadTimeout>
 8000edc:	0003      	movs	r3, r0
                       n, TIME_INFINITE);
}
 8000ede:	0018      	movs	r0, r3
 8000ee0:	b005      	add	sp, #20
 8000ee2:	bd00      	pop	{pc}
	...

08000ef0 <put.lto_priv.60>:

static msg_t put(void *ip, uint8_t b) {
 8000ef0:	b500      	push	{lr}
 8000ef2:	b083      	sub	sp, #12
 8000ef4:	9001      	str	r0, [sp, #4]
 8000ef6:	000a      	movs	r2, r1
 8000ef8:	466b      	mov	r3, sp
 8000efa:	3303      	adds	r3, #3
 8000efc:	701a      	strb	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000efe:	9b01      	ldr	r3, [sp, #4]
 8000f00:	3330      	adds	r3, #48	; 0x30
 8000f02:	0018      	movs	r0, r3
 8000f04:	2301      	movs	r3, #1
 8000f06:	425a      	negs	r2, r3
 8000f08:	466b      	mov	r3, sp
 8000f0a:	3303      	adds	r3, #3
 8000f0c:	781b      	ldrb	r3, [r3, #0]
 8000f0e:	0019      	movs	r1, r3
 8000f10:	f000 fcb6 	bl	8001880 <chOQPutTimeout>
 8000f14:	0003      	movs	r3, r0
}
 8000f16:	0018      	movs	r0, r3
 8000f18:	b003      	add	sp, #12
 8000f1a:	bd00      	pop	{pc}
 8000f1c:	0000      	movs	r0, r0
	...

08000f20 <get.lto_priv.61>:

static msg_t get(void *ip) {
 8000f20:	b500      	push	{lr}
 8000f22:	b083      	sub	sp, #12
 8000f24:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000f26:	9b01      	ldr	r3, [sp, #4]
 8000f28:	330c      	adds	r3, #12
 8000f2a:	001a      	movs	r2, r3
 8000f2c:	2301      	movs	r3, #1
 8000f2e:	425b      	negs	r3, r3
 8000f30:	0019      	movs	r1, r3
 8000f32:	0010      	movs	r0, r2
 8000f34:	f000 fbdc 	bl	80016f0 <chIQGetTimeout>
 8000f38:	0003      	movs	r3, r0
}
 8000f3a:	0018      	movs	r0, r3
 8000f3c:	b003      	add	sp, #12
 8000f3e:	bd00      	pop	{pc}

08000f40 <putt.lto_priv.62>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8000f40:	b500      	push	{lr}
 8000f42:	b085      	sub	sp, #20
 8000f44:	9003      	str	r0, [sp, #12]
 8000f46:	9201      	str	r2, [sp, #4]
 8000f48:	230b      	movs	r3, #11
 8000f4a:	446b      	add	r3, sp
 8000f4c:	1c0a      	adds	r2, r1, #0
 8000f4e:	701a      	strb	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000f50:	9b03      	ldr	r3, [sp, #12]
 8000f52:	3330      	adds	r3, #48	; 0x30
 8000f54:	0018      	movs	r0, r3
 8000f56:	9a01      	ldr	r2, [sp, #4]
 8000f58:	230b      	movs	r3, #11
 8000f5a:	446b      	add	r3, sp
 8000f5c:	781b      	ldrb	r3, [r3, #0]
 8000f5e:	0019      	movs	r1, r3
 8000f60:	f000 fc8e 	bl	8001880 <chOQPutTimeout>
 8000f64:	0003      	movs	r3, r0
}
 8000f66:	0018      	movs	r0, r3
 8000f68:	b005      	add	sp, #20
 8000f6a:	bd00      	pop	{pc}
 8000f6c:	0000      	movs	r0, r0
	...

08000f70 <gett.lto_priv.63>:

static msg_t gett(void *ip, systime_t timeout) {
 8000f70:	b500      	push	{lr}
 8000f72:	b083      	sub	sp, #12
 8000f74:	9001      	str	r0, [sp, #4]
 8000f76:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000f78:	9b01      	ldr	r3, [sp, #4]
 8000f7a:	330c      	adds	r3, #12
 8000f7c:	9a00      	ldr	r2, [sp, #0]
 8000f7e:	0011      	movs	r1, r2
 8000f80:	0018      	movs	r0, r3
 8000f82:	f000 fbb5 	bl	80016f0 <chIQGetTimeout>
 8000f86:	0003      	movs	r3, r0
}
 8000f88:	0018      	movs	r0, r3
 8000f8a:	b003      	add	sp, #12
 8000f8c:	bd00      	pop	{pc}
 8000f8e:	46c0      	nop			; (mov r8, r8)

08000f90 <writet.lto_priv.64>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8000f90:	b500      	push	{lr}
 8000f92:	b085      	sub	sp, #20
 8000f94:	9003      	str	r0, [sp, #12]
 8000f96:	9102      	str	r1, [sp, #8]
 8000f98:	9201      	str	r2, [sp, #4]
 8000f9a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000f9c:	9b03      	ldr	r3, [sp, #12]
 8000f9e:	3330      	adds	r3, #48	; 0x30
 8000fa0:	0018      	movs	r0, r3
 8000fa2:	9b00      	ldr	r3, [sp, #0]
 8000fa4:	9a01      	ldr	r2, [sp, #4]
 8000fa6:	9902      	ldr	r1, [sp, #8]
 8000fa8:	f000 fce2 	bl	8001970 <chOQWriteTimeout>
 8000fac:	0003      	movs	r3, r0
}
 8000fae:	0018      	movs	r0, r3
 8000fb0:	b005      	add	sp, #20
 8000fb2:	bd00      	pop	{pc}
	...

08000fc0 <readt.lto_priv.65>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8000fc0:	b500      	push	{lr}
 8000fc2:	b085      	sub	sp, #20
 8000fc4:	9003      	str	r0, [sp, #12]
 8000fc6:	9102      	str	r1, [sp, #8]
 8000fc8:	9201      	str	r2, [sp, #4]
 8000fca:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000fcc:	9b03      	ldr	r3, [sp, #12]
 8000fce:	330c      	adds	r3, #12
 8000fd0:	0018      	movs	r0, r3
 8000fd2:	9b00      	ldr	r3, [sp, #0]
 8000fd4:	9a01      	ldr	r2, [sp, #4]
 8000fd6:	9902      	ldr	r1, [sp, #8]
 8000fd8:	f000 fbd2 	bl	8001780 <chIQReadTimeout>
 8000fdc:	0003      	movs	r3, r0
}
 8000fde:	0018      	movs	r0, r3
 8000fe0:	b005      	add	sp, #20
 8000fe2:	bd00      	pop	{pc}
	...

08000ff0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8000ff0:	b510      	push	{r4, lr}

  sd_lld_init();
 8000ff2:	f7ff fe2d 	bl	8000c50 <sd_lld_init>
}
 8000ff6:	bd10      	pop	{r4, pc}
	...

08001000 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001000:	b500      	push	{lr}
 8001002:	b087      	sub	sp, #28
 8001004:	9005      	str	r0, [sp, #20]
 8001006:	9104      	str	r1, [sp, #16]
 8001008:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 800100a:	9b05      	ldr	r3, [sp, #20]
 800100c:	4a12      	ldr	r2, [pc, #72]	; (8001058 <sdObjectInit+0x58>)
 800100e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8001010:	9b05      	ldr	r3, [sp, #20]
 8001012:	3304      	adds	r3, #4
 8001014:	0018      	movs	r0, r3
 8001016:	f7ff ff1b 	bl	8000e50 <osalEventObjectInit>
  sdp->state = SD_STOP;
 800101a:	9b05      	ldr	r3, [sp, #20]
 800101c:	2201      	movs	r2, #1
 800101e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001020:	9b05      	ldr	r3, [sp, #20]
 8001022:	330c      	adds	r3, #12
 8001024:	0018      	movs	r0, r3
 8001026:	9b05      	ldr	r3, [sp, #20]
 8001028:	3354      	adds	r3, #84	; 0x54
 800102a:	0019      	movs	r1, r3
 800102c:	9a04      	ldr	r2, [sp, #16]
 800102e:	9b05      	ldr	r3, [sp, #20]
 8001030:	9300      	str	r3, [sp, #0]
 8001032:	0013      	movs	r3, r2
 8001034:	2210      	movs	r2, #16
 8001036:	f000 fafb 	bl	8001630 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 800103a:	9b05      	ldr	r3, [sp, #20]
 800103c:	3330      	adds	r3, #48	; 0x30
 800103e:	0018      	movs	r0, r3
 8001040:	9b05      	ldr	r3, [sp, #20]
 8001042:	3364      	adds	r3, #100	; 0x64
 8001044:	0019      	movs	r1, r3
 8001046:	9a03      	ldr	r2, [sp, #12]
 8001048:	9b05      	ldr	r3, [sp, #20]
 800104a:	9300      	str	r3, [sp, #0]
 800104c:	0013      	movs	r3, r2
 800104e:	2210      	movs	r2, #16
 8001050:	f000 fbee 	bl	8001830 <chOQObjectInit>
}
 8001054:	b007      	add	sp, #28
 8001056:	bd00      	pop	{pc}
 8001058:	08002fe0 	.word	0x08002fe0
 800105c:	00000000 	.word	0x00000000

08001060 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001060:	b500      	push	{lr}
 8001062:	b083      	sub	sp, #12
 8001064:	9001      	str	r0, [sp, #4]
 8001066:	000a      	movs	r2, r1
 8001068:	466b      	mov	r3, sp
 800106a:	3303      	adds	r3, #3
 800106c:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800106e:	9b01      	ldr	r3, [sp, #4]
 8001070:	330c      	adds	r3, #12
 8001072:	0018      	movs	r0, r3
 8001074:	f7ff fedc 	bl	8000e30 <chIQIsEmptyI>
 8001078:	1e03      	subs	r3, r0, #0
 800107a:	d005      	beq.n	8001088 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800107c:	9b01      	ldr	r3, [sp, #4]
 800107e:	3304      	adds	r3, #4
 8001080:	2104      	movs	r1, #4
 8001082:	0018      	movs	r0, r3
 8001084:	f7ff fef4 	bl	8000e70 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8001088:	9b01      	ldr	r3, [sp, #4]
 800108a:	330c      	adds	r3, #12
 800108c:	001a      	movs	r2, r3
 800108e:	466b      	mov	r3, sp
 8001090:	3303      	adds	r3, #3
 8001092:	781b      	ldrb	r3, [r3, #0]
 8001094:	0019      	movs	r1, r3
 8001096:	0010      	movs	r0, r2
 8001098:	f000 faf2 	bl	8001680 <chIQPutI>
 800109c:	1e03      	subs	r3, r0, #0
 800109e:	da05      	bge.n	80010ac <sdIncomingDataI+0x4c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80010a0:	9b01      	ldr	r3, [sp, #4]
 80010a2:	3304      	adds	r3, #4
 80010a4:	2180      	movs	r1, #128	; 0x80
 80010a6:	0018      	movs	r0, r3
 80010a8:	f7ff fee2 	bl	8000e70 <osalEventBroadcastFlagsI>
}
 80010ac:	b003      	add	sp, #12
 80010ae:	bd00      	pop	{pc}

080010b0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80010b0:	b530      	push	{r4, r5, lr}
 80010b2:	b083      	sub	sp, #12
 80010b4:	9001      	str	r0, [sp, #4]
 80010b6:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80010b8:	4c1b      	ldr	r4, [pc, #108]	; (8001128 <nvicEnableVector+0x78>)
 80010ba:	9b01      	ldr	r3, [sp, #4]
 80010bc:	089b      	lsrs	r3, r3, #2
 80010be:	491a      	ldr	r1, [pc, #104]	; (8001128 <nvicEnableVector+0x78>)
 80010c0:	9a01      	ldr	r2, [sp, #4]
 80010c2:	0892      	lsrs	r2, r2, #2
 80010c4:	32c0      	adds	r2, #192	; 0xc0
 80010c6:	0092      	lsls	r2, r2, #2
 80010c8:	5852      	ldr	r2, [r2, r1]
 80010ca:	9901      	ldr	r1, [sp, #4]
 80010cc:	2003      	movs	r0, #3
 80010ce:	4001      	ands	r1, r0
 80010d0:	00c9      	lsls	r1, r1, #3
 80010d2:	20ff      	movs	r0, #255	; 0xff
 80010d4:	4088      	lsls	r0, r1
 80010d6:	0001      	movs	r1, r0
 80010d8:	43c9      	mvns	r1, r1
 80010da:	4011      	ands	r1, r2
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 80010dc:	9a00      	ldr	r2, [sp, #0]
 80010de:	0190      	lsls	r0, r2, #6
 80010e0:	9a01      	ldr	r2, [sp, #4]
 80010e2:	2503      	movs	r5, #3
 80010e4:	402a      	ands	r2, r5
 80010e6:	00d2      	lsls	r2, r2, #3
 80010e8:	4090      	lsls	r0, r2
 80010ea:	0002      	movs	r2, r0
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80010ec:	430a      	orrs	r2, r1
 80010ee:	33c0      	adds	r3, #192	; 0xc0
 80010f0:	009b      	lsls	r3, r3, #2
 80010f2:	511a      	str	r2, [r3, r4]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80010f4:	490c      	ldr	r1, [pc, #48]	; (8001128 <nvicEnableVector+0x78>)
 80010f6:	9b01      	ldr	r3, [sp, #4]
 80010f8:	095b      	lsrs	r3, r3, #5
 80010fa:	9a01      	ldr	r2, [sp, #4]
 80010fc:	201f      	movs	r0, #31
 80010fe:	4002      	ands	r2, r0
 8001100:	2001      	movs	r0, #1
 8001102:	4090      	lsls	r0, r2
 8001104:	0002      	movs	r2, r0
 8001106:	3360      	adds	r3, #96	; 0x60
 8001108:	009b      	lsls	r3, r3, #2
 800110a:	505a      	str	r2, [r3, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800110c:	4906      	ldr	r1, [pc, #24]	; (8001128 <nvicEnableVector+0x78>)
 800110e:	9b01      	ldr	r3, [sp, #4]
 8001110:	095b      	lsrs	r3, r3, #5
 8001112:	9a01      	ldr	r2, [sp, #4]
 8001114:	201f      	movs	r0, #31
 8001116:	4002      	ands	r2, r0
 8001118:	2001      	movs	r0, #1
 800111a:	4090      	lsls	r0, r2
 800111c:	0002      	movs	r2, r0
 800111e:	009b      	lsls	r3, r3, #2
 8001120:	505a      	str	r2, [r3, r1]
}
 8001122:	b003      	add	sp, #12
 8001124:	bd30      	pop	{r4, r5, pc}
 8001126:	46c0      	nop			; (mov r8, r8)
 8001128:	e000e100 	.word	0xe000e100
 800112c:	00000000 	.word	0x00000000

08001130 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8001130:	b530      	push	{r4, r5, lr}
 8001132:	b083      	sub	sp, #12
 8001134:	9001      	str	r0, [sp, #4]
 8001136:	9100      	str	r1, [sp, #0]

  osalDbgCheck(handler < 12U);

#if defined(__CORE_CM0_H_GENERIC)
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
 8001138:	4c14      	ldr	r4, [pc, #80]	; (800118c <nvicSetSystemHandlerPriority+0x5c>)
 800113a:	9b01      	ldr	r3, [sp, #4]
 800113c:	220f      	movs	r2, #15
 800113e:	4013      	ands	r3, r2
 8001140:	3b08      	subs	r3, #8
 8001142:	0899      	lsrs	r1, r3, #2
 8001144:	4a11      	ldr	r2, [pc, #68]	; (800118c <nvicSetSystemHandlerPriority+0x5c>)
 8001146:	9b01      	ldr	r3, [sp, #4]
 8001148:	200f      	movs	r0, #15
 800114a:	4003      	ands	r3, r0
 800114c:	3b08      	subs	r3, #8
 800114e:	089b      	lsrs	r3, r3, #2
 8001150:	3306      	adds	r3, #6
 8001152:	009b      	lsls	r3, r3, #2
 8001154:	18d3      	adds	r3, r2, r3
 8001156:	3304      	adds	r3, #4
 8001158:	681b      	ldr	r3, [r3, #0]
 800115a:	9a01      	ldr	r2, [sp, #4]
 800115c:	2003      	movs	r0, #3
 800115e:	4002      	ands	r2, r0
 8001160:	00d2      	lsls	r2, r2, #3
 8001162:	20ff      	movs	r0, #255	; 0xff
 8001164:	4090      	lsls	r0, r2
 8001166:	0002      	movs	r2, r0
 8001168:	43d2      	mvns	r2, r2
 800116a:	401a      	ands	r2, r3
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
 800116c:	9b00      	ldr	r3, [sp, #0]
 800116e:	0198      	lsls	r0, r3, #6
 8001170:	9b01      	ldr	r3, [sp, #4]
 8001172:	2503      	movs	r5, #3
 8001174:	402b      	ands	r3, r5
 8001176:	00db      	lsls	r3, r3, #3
 8001178:	4098      	lsls	r0, r3
 800117a:	0003      	movs	r3, r0
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {

  osalDbgCheck(handler < 12U);

#if defined(__CORE_CM0_H_GENERIC)
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
 800117c:	431a      	orrs	r2, r3
 800117e:	1d8b      	adds	r3, r1, #6
 8001180:	009b      	lsls	r3, r3, #2
 8001182:	18e3      	adds	r3, r4, r3
 8001184:	3304      	adds	r3, #4
 8001186:	601a      	str	r2, [r3, #0]
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
#endif
}
 8001188:	b003      	add	sp, #12
 800118a:	bd30      	pop	{r4, r5, pc}
 800118c:	e000ed00 	.word	0xe000ed00

08001190 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001190:	4b15      	ldr	r3, [pc, #84]	; (80011e8 <hal_lld_backup_domain_init+0x58>)
 8001192:	4a15      	ldr	r2, [pc, #84]	; (80011e8 <hal_lld_backup_domain_init+0x58>)
 8001194:	6812      	ldr	r2, [r2, #0]
 8001196:	2180      	movs	r1, #128	; 0x80
 8001198:	0049      	lsls	r1, r1, #1
 800119a:	430a      	orrs	r2, r1
 800119c:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 800119e:	4b13      	ldr	r3, [pc, #76]	; (80011ec <hal_lld_backup_domain_init+0x5c>)
 80011a0:	6a1a      	ldr	r2, [r3, #32]
 80011a2:	23c0      	movs	r3, #192	; 0xc0
 80011a4:	009b      	lsls	r3, r3, #2
 80011a6:	401a      	ands	r2, r3
 80011a8:	2380      	movs	r3, #128	; 0x80
 80011aa:	009b      	lsls	r3, r3, #2
 80011ac:	429a      	cmp	r2, r3
 80011ae:	d006      	beq.n	80011be <hal_lld_backup_domain_init+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80011b0:	4b0e      	ldr	r3, [pc, #56]	; (80011ec <hal_lld_backup_domain_init+0x5c>)
 80011b2:	2280      	movs	r2, #128	; 0x80
 80011b4:	0252      	lsls	r2, r2, #9
 80011b6:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 80011b8:	4b0c      	ldr	r3, [pc, #48]	; (80011ec <hal_lld_backup_domain_init+0x5c>)
 80011ba:	2200      	movs	r2, #0
 80011bc:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80011be:	4b0b      	ldr	r3, [pc, #44]	; (80011ec <hal_lld_backup_domain_init+0x5c>)
 80011c0:	6a1a      	ldr	r2, [r3, #32]
 80011c2:	2380      	movs	r3, #128	; 0x80
 80011c4:	021b      	lsls	r3, r3, #8
 80011c6:	4013      	ands	r3, r2
 80011c8:	d10d      	bne.n	80011e6 <hal_lld_backup_domain_init+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80011ca:	4b08      	ldr	r3, [pc, #32]	; (80011ec <hal_lld_backup_domain_init+0x5c>)
 80011cc:	4a07      	ldr	r2, [pc, #28]	; (80011ec <hal_lld_backup_domain_init+0x5c>)
 80011ce:	6a12      	ldr	r2, [r2, #32]
 80011d0:	2180      	movs	r1, #128	; 0x80
 80011d2:	0089      	lsls	r1, r1, #2
 80011d4:	430a      	orrs	r2, r1
 80011d6:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 80011d8:	4b04      	ldr	r3, [pc, #16]	; (80011ec <hal_lld_backup_domain_init+0x5c>)
 80011da:	4a04      	ldr	r2, [pc, #16]	; (80011ec <hal_lld_backup_domain_init+0x5c>)
 80011dc:	6a12      	ldr	r2, [r2, #32]
 80011de:	2180      	movs	r1, #128	; 0x80
 80011e0:	0209      	lsls	r1, r1, #8
 80011e2:	430a      	orrs	r2, r1
 80011e4:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 80011e6:	4770      	bx	lr
 80011e8:	40007000 	.word	0x40007000
 80011ec:	40021000 	.word	0x40021000

080011f0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80011f0:	b510      	push	{r4, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80011f2:	4b12      	ldr	r3, [pc, #72]	; (800123c <hal_lld_init+0x4c>)
 80011f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80011f6:	4b11      	ldr	r3, [pc, #68]	; (800123c <hal_lld_init+0x4c>)
 80011f8:	2201      	movs	r2, #1
 80011fa:	4252      	negs	r2, r2
 80011fc:	629a      	str	r2, [r3, #40]	; 0x28
 80011fe:	4b0f      	ldr	r3, [pc, #60]	; (800123c <hal_lld_init+0x4c>)
 8001200:	2200      	movs	r2, #0
 8001202:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8001204:	4b0d      	ldr	r3, [pc, #52]	; (800123c <hal_lld_init+0x4c>)
 8001206:	691b      	ldr	r3, [r3, #16]
 8001208:	4b0c      	ldr	r3, [pc, #48]	; (800123c <hal_lld_init+0x4c>)
 800120a:	2201      	movs	r2, #1
 800120c:	4252      	negs	r2, r2
 800120e:	611a      	str	r2, [r3, #16]
 8001210:	4b0a      	ldr	r3, [pc, #40]	; (800123c <hal_lld_init+0x4c>)
 8001212:	2200      	movs	r2, #0
 8001214:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001216:	4b09      	ldr	r3, [pc, #36]	; (800123c <hal_lld_init+0x4c>)
 8001218:	4a08      	ldr	r2, [pc, #32]	; (800123c <hal_lld_init+0x4c>)
 800121a:	68d2      	ldr	r2, [r2, #12]
 800121c:	4908      	ldr	r1, [pc, #32]	; (8001240 <hal_lld_init+0x50>)
 800121e:	430a      	orrs	r2, r1
 8001220:	60da      	str	r2, [r3, #12]
 8001222:	4b06      	ldr	r3, [pc, #24]	; (800123c <hal_lld_init+0x4c>)
 8001224:	2200      	movs	r2, #0
 8001226:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001228:	4b04      	ldr	r3, [pc, #16]	; (800123c <hal_lld_init+0x4c>)
 800122a:	4a04      	ldr	r2, [pc, #16]	; (800123c <hal_lld_init+0x4c>)
 800122c:	69d2      	ldr	r2, [r2, #28]
 800122e:	2180      	movs	r1, #128	; 0x80
 8001230:	0549      	lsls	r1, r1, #21
 8001232:	430a      	orrs	r2, r1
 8001234:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8001236:	f7ff ffab 	bl	8001190 <hal_lld_backup_domain_init>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800123a:	bd10      	pop	{r4, pc}
 800123c:	40021000 	.word	0x40021000
 8001240:	ffbfffff 	.word	0xffbfffff
	...

08001250 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001250:	4b39      	ldr	r3, [pc, #228]	; (8001338 <stm32_clock_init+0xe8>)
 8001252:	4a39      	ldr	r2, [pc, #228]	; (8001338 <stm32_clock_init+0xe8>)
 8001254:	6812      	ldr	r2, [r2, #0]
 8001256:	2101      	movs	r1, #1
 8001258:	430a      	orrs	r2, r1
 800125a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800125c:	4b36      	ldr	r3, [pc, #216]	; (8001338 <stm32_clock_init+0xe8>)
 800125e:	681b      	ldr	r3, [r3, #0]
 8001260:	2202      	movs	r2, #2
 8001262:	4013      	ands	r3, r2
 8001264:	d0fa      	beq.n	800125c <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001266:	4b34      	ldr	r3, [pc, #208]	; (8001338 <stm32_clock_init+0xe8>)
 8001268:	4a33      	ldr	r2, [pc, #204]	; (8001338 <stm32_clock_init+0xe8>)
 800126a:	6852      	ldr	r2, [r2, #4]
 800126c:	2103      	movs	r1, #3
 800126e:	438a      	bics	r2, r1
 8001270:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001272:	4b31      	ldr	r3, [pc, #196]	; (8001338 <stm32_clock_init+0xe8>)
 8001274:	4a30      	ldr	r2, [pc, #192]	; (8001338 <stm32_clock_init+0xe8>)
 8001276:	6852      	ldr	r2, [r2, #4]
 8001278:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800127a:	4b2f      	ldr	r3, [pc, #188]	; (8001338 <stm32_clock_init+0xe8>)
 800127c:	685b      	ldr	r3, [r3, #4]
 800127e:	220c      	movs	r2, #12
 8001280:	4013      	ands	r3, r2
 8001282:	d1fa      	bne.n	800127a <stm32_clock_init+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001284:	4b2c      	ldr	r3, [pc, #176]	; (8001338 <stm32_clock_init+0xe8>)
 8001286:	4a2c      	ldr	r2, [pc, #176]	; (8001338 <stm32_clock_init+0xe8>)
 8001288:	6812      	ldr	r2, [r2, #0]
 800128a:	21f9      	movs	r1, #249	; 0xf9
 800128c:	400a      	ands	r2, r1
 800128e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001290:	4b29      	ldr	r3, [pc, #164]	; (8001338 <stm32_clock_init+0xe8>)
 8001292:	2200      	movs	r2, #0
 8001294:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001296:	4b28      	ldr	r3, [pc, #160]	; (8001338 <stm32_clock_init+0xe8>)
 8001298:	4a27      	ldr	r2, [pc, #156]	; (8001338 <stm32_clock_init+0xe8>)
 800129a:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800129c:	2101      	movs	r1, #1
 800129e:	430a      	orrs	r2, r1
 80012a0:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 80012a2:	4b25      	ldr	r3, [pc, #148]	; (8001338 <stm32_clock_init+0xe8>)
 80012a4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80012a6:	2202      	movs	r2, #2
 80012a8:	4013      	ands	r3, r2
 80012aa:	d0fa      	beq.n	80012a2 <stm32_clock_init+0x52>
    ;                                       /* Waits until HSI14 is stable. */
#endif

#if STM32_HSI48_ENABLED
  /* HSI48 activation.*/
  RCC->CR2 |= RCC_CR2_HSI48ON;
 80012ac:	4b22      	ldr	r3, [pc, #136]	; (8001338 <stm32_clock_init+0xe8>)
 80012ae:	4a22      	ldr	r2, [pc, #136]	; (8001338 <stm32_clock_init+0xe8>)
 80012b0:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80012b2:	2180      	movs	r1, #128	; 0x80
 80012b4:	0249      	lsls	r1, r1, #9
 80012b6:	430a      	orrs	r2, r1
 80012b8:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI48RDY))
 80012ba:	4b1f      	ldr	r3, [pc, #124]	; (8001338 <stm32_clock_init+0xe8>)
 80012bc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80012be:	2380      	movs	r3, #128	; 0x80
 80012c0:	029b      	lsls	r3, r3, #10
 80012c2:	4013      	ands	r3, r2
 80012c4:	d0f9      	beq.n	80012ba <stm32_clock_init+0x6a>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80012c6:	4b1c      	ldr	r3, [pc, #112]	; (8001338 <stm32_clock_init+0xe8>)
 80012c8:	4a1b      	ldr	r2, [pc, #108]	; (8001338 <stm32_clock_init+0xe8>)
 80012ca:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80012cc:	2101      	movs	r1, #1
 80012ce:	430a      	orrs	r2, r1
 80012d0:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80012d2:	4b19      	ldr	r3, [pc, #100]	; (8001338 <stm32_clock_init+0xe8>)
 80012d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80012d6:	2202      	movs	r2, #2
 80012d8:	4013      	ands	r3, r2
 80012da:	d0fa      	beq.n	80012d2 <stm32_clock_init+0x82>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 80012dc:	4b16      	ldr	r3, [pc, #88]	; (8001338 <stm32_clock_init+0xe8>)
 80012de:	22a0      	movs	r2, #160	; 0xa0
 80012e0:	0392      	lsls	r2, r2, #14
 80012e2:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80012e4:	4b14      	ldr	r3, [pc, #80]	; (8001338 <stm32_clock_init+0xe8>)
 80012e6:	2200      	movs	r2, #0
 80012e8:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 80012ea:	4b13      	ldr	r3, [pc, #76]	; (8001338 <stm32_clock_init+0xe8>)
 80012ec:	2200      	movs	r2, #0
 80012ee:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80012f0:	4b11      	ldr	r3, [pc, #68]	; (8001338 <stm32_clock_init+0xe8>)
 80012f2:	4a11      	ldr	r2, [pc, #68]	; (8001338 <stm32_clock_init+0xe8>)
 80012f4:	6812      	ldr	r2, [r2, #0]
 80012f6:	2180      	movs	r1, #128	; 0x80
 80012f8:	0449      	lsls	r1, r1, #17
 80012fa:	430a      	orrs	r2, r1
 80012fc:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80012fe:	4b0e      	ldr	r3, [pc, #56]	; (8001338 <stm32_clock_init+0xe8>)
 8001300:	681a      	ldr	r2, [r3, #0]
 8001302:	2380      	movs	r3, #128	; 0x80
 8001304:	049b      	lsls	r3, r3, #18
 8001306:	4013      	ands	r3, r2
 8001308:	d0f9      	beq.n	80012fe <stm32_clock_init+0xae>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800130a:	4b0c      	ldr	r3, [pc, #48]	; (800133c <stm32_clock_init+0xec>)
 800130c:	2211      	movs	r2, #17
 800130e:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001310:	4b09      	ldr	r3, [pc, #36]	; (8001338 <stm32_clock_init+0xe8>)
 8001312:	4a09      	ldr	r2, [pc, #36]	; (8001338 <stm32_clock_init+0xe8>)
 8001314:	6852      	ldr	r2, [r2, #4]
 8001316:	2102      	movs	r1, #2
 8001318:	430a      	orrs	r2, r1
 800131a:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800131c:	4b06      	ldr	r3, [pc, #24]	; (8001338 <stm32_clock_init+0xe8>)
 800131e:	685b      	ldr	r3, [r3, #4]
 8001320:	220c      	movs	r2, #12
 8001322:	4013      	ands	r3, r2
 8001324:	2b08      	cmp	r3, #8
 8001326:	d1f9      	bne.n	800131c <stm32_clock_init+0xcc>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001328:	4b03      	ldr	r3, [pc, #12]	; (8001338 <stm32_clock_init+0xe8>)
 800132a:	4a03      	ldr	r2, [pc, #12]	; (8001338 <stm32_clock_init+0xe8>)
 800132c:	6992      	ldr	r2, [r2, #24]
 800132e:	2101      	movs	r1, #1
 8001330:	430a      	orrs	r2, r1
 8001332:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 8001334:	4770      	bx	lr
 8001336:	46c0      	nop			; (mov r8, r8)
 8001338:	40021000 	.word	0x40021000
 800133c:	40022000 	.word	0x40022000

08001340 <port_lock.lto_priv.144>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001340:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001342:	4770      	bx	lr
	...

08001350 <port_unlock.lto_priv.141>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001350:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001352:	4770      	bx	lr
	...

08001360 <port_lock_from_isr>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001360:	b510      	push	{r4, lr}

  port_lock();
 8001362:	f7ff ffed 	bl	8001340 <port_lock.lto_priv.144>
}
 8001366:	bd10      	pop	{r4, pc}
	...

08001370 <port_unlock_from_isr>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001370:	b510      	push	{r4, lr}

  port_unlock();
 8001372:	f7ff ffed 	bl	8001350 <port_unlock.lto_priv.141>
}
 8001376:	bd10      	pop	{r4, pc}
	...

08001380 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001380:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8001382:	f7ff ffed 	bl	8001360 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001386:	bd10      	pop	{r4, pc}
	...

08001390 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001390:	b510      	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001392:	f7ff ffed 	bl	8001370 <port_unlock_from_isr>
}
 8001396:	bd10      	pop	{r4, pc}
	...

080013a0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80013a0:	b510      	push	{r4, lr}

  chSysLockFromISR();
 80013a2:	f7ff ffed 	bl	8001380 <chSysLockFromISR>
}
 80013a6:	bd10      	pop	{r4, pc}
	...

080013b0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80013b0:	b510      	push	{r4, lr}

  chSysUnlockFromISR();
 80013b2:	f7ff ffed 	bl	8001390 <chSysUnlockFromISR>
}
 80013b6:	bd10      	pop	{r4, pc}
	...

080013c0 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 80013c0:	b510      	push	{r4, lr}

  chSysTimerHandlerI();
 80013c2:	f000 feb5 	bl	8002130 <chSysTimerHandlerI>
}
 80013c6:	bd10      	pop	{r4, pc}
	...

080013d0 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 80013d0:	b500      	push	{lr}
 80013d2:	b083      	sub	sp, #12
 80013d4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80013d6:	9301      	str	r3, [sp, #4]

  osalSysLockFromISR();
 80013d8:	f7ff ffe2 	bl	80013a0 <osalSysLockFromISR>
  osalOsTimerHandlerI();
 80013dc:	f7ff fff0 	bl	80013c0 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
 80013e0:	f7ff ffe6 	bl	80013b0 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 80013e4:	9b01      	ldr	r3, [sp, #4]
 80013e6:	0018      	movs	r0, r3
 80013e8:	f000 fbe2 	bl	8001bb0 <_port_irq_epilogue>
}
 80013ec:	b003      	add	sp, #12
 80013ee:	bd00      	pop	{pc}

080013f0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80013f0:	b510      	push	{r4, lr}
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 80013f2:	4b07      	ldr	r3, [pc, #28]	; (8001410 <st_lld_init+0x20>)
 80013f4:	4a07      	ldr	r2, [pc, #28]	; (8001414 <st_lld_init+0x24>)
 80013f6:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
 80013f8:	4b05      	ldr	r3, [pc, #20]	; (8001410 <st_lld_init+0x20>)
 80013fa:	2200      	movs	r2, #0
 80013fc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 80013fe:	4b04      	ldr	r3, [pc, #16]	; (8001410 <st_lld_init+0x20>)
 8001400:	2207      	movs	r2, #7
 8001402:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 8001404:	2102      	movs	r1, #2
 8001406:	200b      	movs	r0, #11
 8001408:	f7ff fe92 	bl	8001130 <nvicSetSystemHandlerPriority>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800140c:	bd10      	pop	{r4, pc}
 800140e:	46c0      	nop			; (mov r8, r8)
 8001410:	e000e010 	.word	0xe000e010
 8001414:	000012bf 	.word	0x000012bf
	...

08001420 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8001420:	b082      	sub	sp, #8
 8001422:	9001      	str	r0, [sp, #4]
 8001424:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8001426:	9b00      	ldr	r3, [sp, #0]
 8001428:	685a      	ldr	r2, [r3, #4]
 800142a:	9b01      	ldr	r3, [sp, #4]
 800142c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800142e:	9b00      	ldr	r3, [sp, #0]
 8001430:	689a      	ldr	r2, [r3, #8]
 8001432:	9b01      	ldr	r3, [sp, #4]
 8001434:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001436:	9b00      	ldr	r3, [sp, #0]
 8001438:	68da      	ldr	r2, [r3, #12]
 800143a:	9b01      	ldr	r3, [sp, #4]
 800143c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800143e:	9b00      	ldr	r3, [sp, #0]
 8001440:	691a      	ldr	r2, [r3, #16]
 8001442:	9b01      	ldr	r3, [sp, #4]
 8001444:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001446:	9b00      	ldr	r3, [sp, #0]
 8001448:	695a      	ldr	r2, [r3, #20]
 800144a:	9b01      	ldr	r3, [sp, #4]
 800144c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800144e:	9b00      	ldr	r3, [sp, #0]
 8001450:	699a      	ldr	r2, [r3, #24]
 8001452:	9b01      	ldr	r3, [sp, #4]
 8001454:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001456:	9b00      	ldr	r3, [sp, #0]
 8001458:	681a      	ldr	r2, [r3, #0]
 800145a:	9b01      	ldr	r3, [sp, #4]
 800145c:	601a      	str	r2, [r3, #0]
}
 800145e:	b002      	add	sp, #8
 8001460:	4770      	bx	lr
 8001462:	46c0      	nop			; (mov r8, r8)
	...

08001470 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001470:	b500      	push	{lr}
 8001472:	b083      	sub	sp, #12
 8001474:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001476:	4b12      	ldr	r3, [pc, #72]	; (80014c0 <_pal_lld_init+0x50>)
 8001478:	4a11      	ldr	r2, [pc, #68]	; (80014c0 <_pal_lld_init+0x50>)
 800147a:	6952      	ldr	r2, [r2, #20]
 800147c:	219c      	movs	r1, #156	; 0x9c
 800147e:	03c9      	lsls	r1, r1, #15
 8001480:	430a      	orrs	r2, r1
 8001482:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8001484:	9a01      	ldr	r2, [sp, #4]
 8001486:	2390      	movs	r3, #144	; 0x90
 8001488:	05db      	lsls	r3, r3, #23
 800148a:	0011      	movs	r1, r2
 800148c:	0018      	movs	r0, r3
 800148e:	f7ff ffc7 	bl	8001420 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8001492:	9b01      	ldr	r3, [sp, #4]
 8001494:	331c      	adds	r3, #28
 8001496:	4a0b      	ldr	r2, [pc, #44]	; (80014c4 <_pal_lld_init+0x54>)
 8001498:	0019      	movs	r1, r3
 800149a:	0010      	movs	r0, r2
 800149c:	f7ff ffc0 	bl	8001420 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80014a0:	9b01      	ldr	r3, [sp, #4]
 80014a2:	3338      	adds	r3, #56	; 0x38
 80014a4:	4a08      	ldr	r2, [pc, #32]	; (80014c8 <_pal_lld_init+0x58>)
 80014a6:	0019      	movs	r1, r3
 80014a8:	0010      	movs	r0, r2
 80014aa:	f7ff ffb9 	bl	8001420 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 80014ae:	9b01      	ldr	r3, [sp, #4]
 80014b0:	3354      	adds	r3, #84	; 0x54
 80014b2:	4a06      	ldr	r2, [pc, #24]	; (80014cc <_pal_lld_init+0x5c>)
 80014b4:	0019      	movs	r1, r3
 80014b6:	0010      	movs	r0, r2
 80014b8:	f7ff ffb2 	bl	8001420 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 80014bc:	b003      	add	sp, #12
 80014be:	bd00      	pop	{pc}
 80014c0:	40021000 	.word	0x40021000
 80014c4:	48000400 	.word	0x48000400
 80014c8:	48000800 	.word	0x48000800
 80014cc:	48001400 	.word	0x48001400

080014d0 <Vector7C>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 80014d0:	b500      	push	{lr}
 80014d2:	b083      	sub	sp, #12
 80014d4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80014d6:	9301      	str	r3, [sp, #4]

  pwm_lld_serve_interrupt(&PWMD2);
 80014d8:	4b04      	ldr	r3, [pc, #16]	; (80014ec <Vector7C+0x1c>)
 80014da:	0018      	movs	r0, r3
 80014dc:	f7ff fa10 	bl	8000900 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80014e0:	9b01      	ldr	r3, [sp, #4]
 80014e2:	0018      	movs	r0, r3
 80014e4:	f000 fb64 	bl	8001bb0 <_port_irq_epilogue>
}
 80014e8:	b003      	add	sp, #12
 80014ea:	bd00      	pop	{pc}
 80014ec:	200007e0 	.word	0x200007e0

080014f0 <Vector80>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 80014f0:	b500      	push	{lr}
 80014f2:	b083      	sub	sp, #12
 80014f4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80014f6:	9301      	str	r3, [sp, #4]

  pwm_lld_serve_interrupt(&PWMD3);
 80014f8:	4b04      	ldr	r3, [pc, #16]	; (800150c <Vector80+0x1c>)
 80014fa:	0018      	movs	r0, r3
 80014fc:	f7ff fa00 	bl	8000900 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8001500:	9b01      	ldr	r3, [sp, #4]
 8001502:	0018      	movs	r0, r3
 8001504:	f000 fb54 	bl	8001bb0 <_port_irq_epilogue>
}
 8001508:	b003      	add	sp, #12
 800150a:	bd00      	pop	{pc}
 800150c:	200007fc 	.word	0x200007fc

08001510 <port_lock.lto_priv.184>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001510:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001512:	4770      	bx	lr
	...

08001520 <port_unlock.lto_priv.178>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001520:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001522:	4770      	bx	lr
	...

08001530 <queue_init.lto_priv.175>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001530:	b082      	sub	sp, #8
 8001532:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001534:	9b01      	ldr	r3, [sp, #4]
 8001536:	9a01      	ldr	r2, [sp, #4]
 8001538:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800153a:	9b01      	ldr	r3, [sp, #4]
 800153c:	9a01      	ldr	r2, [sp, #4]
 800153e:	605a      	str	r2, [r3, #4]
}
 8001540:	b002      	add	sp, #8
 8001542:	4770      	bx	lr
	...

08001550 <chSysLock.lto_priv.171>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001550:	b510      	push	{r4, lr}

  port_lock();
 8001552:	f7ff ffdd 	bl	8001510 <port_lock.lto_priv.184>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001556:	bd10      	pop	{r4, pc}
	...

08001560 <chSysUnlock.lto_priv.165>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001560:	b510      	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001562:	f7ff ffdd 	bl	8001520 <port_unlock.lto_priv.178>
}
 8001566:	bd10      	pop	{r4, pc}
	...

08001570 <chThdQueueObjectInit.lto_priv.161>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8001570:	b500      	push	{lr}
 8001572:	b083      	sub	sp, #12
 8001574:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8001576:	9b01      	ldr	r3, [sp, #4]
 8001578:	0018      	movs	r0, r3
 800157a:	f7ff ffd9 	bl	8001530 <queue_init.lto_priv.175>
}
 800157e:	b003      	add	sp, #12
 8001580:	bd00      	pop	{pc}
 8001582:	46c0      	nop			; (mov r8, r8)
	...

08001590 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8001590:	b082      	sub	sp, #8
 8001592:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8001594:	9b01      	ldr	r3, [sp, #4]
 8001596:	689b      	ldr	r3, [r3, #8]
 8001598:	425a      	negs	r2, r3
 800159a:	4153      	adcs	r3, r2
 800159c:	b2db      	uxtb	r3, r3
}
 800159e:	0018      	movs	r0, r3
 80015a0:	b002      	add	sp, #8
 80015a2:	4770      	bx	lr
	...

080015b0 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 80015b0:	b082      	sub	sp, #8
 80015b2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80015b4:	9b01      	ldr	r3, [sp, #4]
 80015b6:	695a      	ldr	r2, [r3, #20]
 80015b8:	9b01      	ldr	r3, [sp, #4]
 80015ba:	699b      	ldr	r3, [r3, #24]
 80015bc:	429a      	cmp	r2, r3
 80015be:	d105      	bne.n	80015cc <chIQIsFullI+0x1c>
 80015c0:	9b01      	ldr	r3, [sp, #4]
 80015c2:	689b      	ldr	r3, [r3, #8]
 80015c4:	2b00      	cmp	r3, #0
 80015c6:	d001      	beq.n	80015cc <chIQIsFullI+0x1c>
 80015c8:	2301      	movs	r3, #1
 80015ca:	e000      	b.n	80015ce <chIQIsFullI+0x1e>
 80015cc:	2300      	movs	r3, #0
 80015ce:	1c1a      	adds	r2, r3, #0
 80015d0:	2301      	movs	r3, #1
 80015d2:	4013      	ands	r3, r2
 80015d4:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 80015d6:	0018      	movs	r0, r3
 80015d8:	b002      	add	sp, #8
 80015da:	4770      	bx	lr
 80015dc:	0000      	movs	r0, r0
	...

080015e0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 80015e0:	b082      	sub	sp, #8
 80015e2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80015e4:	9b01      	ldr	r3, [sp, #4]
 80015e6:	695a      	ldr	r2, [r3, #20]
 80015e8:	9b01      	ldr	r3, [sp, #4]
 80015ea:	699b      	ldr	r3, [r3, #24]
 80015ec:	429a      	cmp	r2, r3
 80015ee:	d105      	bne.n	80015fc <chOQIsEmptyI+0x1c>
 80015f0:	9b01      	ldr	r3, [sp, #4]
 80015f2:	689b      	ldr	r3, [r3, #8]
 80015f4:	2b00      	cmp	r3, #0
 80015f6:	d001      	beq.n	80015fc <chOQIsEmptyI+0x1c>
 80015f8:	2301      	movs	r3, #1
 80015fa:	e000      	b.n	80015fe <chOQIsEmptyI+0x1e>
 80015fc:	2300      	movs	r3, #0
 80015fe:	1c1a      	adds	r2, r3, #0
 8001600:	2301      	movs	r3, #1
 8001602:	4013      	ands	r3, r2
 8001604:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8001606:	0018      	movs	r0, r3
 8001608:	b002      	add	sp, #8
 800160a:	4770      	bx	lr
 800160c:	0000      	movs	r0, r0
	...

08001610 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8001610:	b082      	sub	sp, #8
 8001612:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8001614:	9b01      	ldr	r3, [sp, #4]
 8001616:	689b      	ldr	r3, [r3, #8]
 8001618:	425a      	negs	r2, r3
 800161a:	4153      	adcs	r3, r2
 800161c:	b2db      	uxtb	r3, r3
}
 800161e:	0018      	movs	r0, r3
 8001620:	b002      	add	sp, #8
 8001622:	4770      	bx	lr
	...

08001630 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8001630:	b500      	push	{lr}
 8001632:	b085      	sub	sp, #20
 8001634:	9003      	str	r0, [sp, #12]
 8001636:	9102      	str	r1, [sp, #8]
 8001638:	9201      	str	r2, [sp, #4]
 800163a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 800163c:	9b03      	ldr	r3, [sp, #12]
 800163e:	0018      	movs	r0, r3
 8001640:	f7ff ff96 	bl	8001570 <chThdQueueObjectInit.lto_priv.161>
  iqp->q_counter = 0;
 8001644:	9b03      	ldr	r3, [sp, #12]
 8001646:	2200      	movs	r2, #0
 8001648:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800164a:	9b03      	ldr	r3, [sp, #12]
 800164c:	9a02      	ldr	r2, [sp, #8]
 800164e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8001650:	9b03      	ldr	r3, [sp, #12]
 8001652:	9a02      	ldr	r2, [sp, #8]
 8001654:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8001656:	9b03      	ldr	r3, [sp, #12]
 8001658:	9a02      	ldr	r2, [sp, #8]
 800165a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800165c:	9a02      	ldr	r2, [sp, #8]
 800165e:	9b01      	ldr	r3, [sp, #4]
 8001660:	18d2      	adds	r2, r2, r3
 8001662:	9b03      	ldr	r3, [sp, #12]
 8001664:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8001666:	9b03      	ldr	r3, [sp, #12]
 8001668:	9a00      	ldr	r2, [sp, #0]
 800166a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800166c:	9b03      	ldr	r3, [sp, #12]
 800166e:	9a06      	ldr	r2, [sp, #24]
 8001670:	621a      	str	r2, [r3, #32]
}
 8001672:	b005      	add	sp, #20
 8001674:	bd00      	pop	{pc}
 8001676:	46c0      	nop			; (mov r8, r8)
	...

08001680 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8001680:	b500      	push	{lr}
 8001682:	b083      	sub	sp, #12
 8001684:	9001      	str	r0, [sp, #4]
 8001686:	000a      	movs	r2, r1
 8001688:	466b      	mov	r3, sp
 800168a:	3303      	adds	r3, #3
 800168c:	701a      	strb	r2, [r3, #0]

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
 800168e:	9b01      	ldr	r3, [sp, #4]
 8001690:	0018      	movs	r0, r3
 8001692:	f7ff ff8d 	bl	80015b0 <chIQIsFullI>
 8001696:	1e03      	subs	r3, r0, #0
 8001698:	d002      	beq.n	80016a0 <chIQPutI+0x20>
    return Q_FULL;
 800169a:	2304      	movs	r3, #4
 800169c:	425b      	negs	r3, r3
 800169e:	e01d      	b.n	80016dc <chIQPutI+0x5c>
  }

  iqp->q_counter++;
 80016a0:	9b01      	ldr	r3, [sp, #4]
 80016a2:	689b      	ldr	r3, [r3, #8]
 80016a4:	1c5a      	adds	r2, r3, #1
 80016a6:	9b01      	ldr	r3, [sp, #4]
 80016a8:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 80016aa:	9b01      	ldr	r3, [sp, #4]
 80016ac:	695b      	ldr	r3, [r3, #20]
 80016ae:	1c59      	adds	r1, r3, #1
 80016b0:	9a01      	ldr	r2, [sp, #4]
 80016b2:	6151      	str	r1, [r2, #20]
 80016b4:	466a      	mov	r2, sp
 80016b6:	3203      	adds	r2, #3
 80016b8:	7812      	ldrb	r2, [r2, #0]
 80016ba:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80016bc:	9b01      	ldr	r3, [sp, #4]
 80016be:	695a      	ldr	r2, [r3, #20]
 80016c0:	9b01      	ldr	r3, [sp, #4]
 80016c2:	691b      	ldr	r3, [r3, #16]
 80016c4:	429a      	cmp	r2, r3
 80016c6:	d303      	bcc.n	80016d0 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
 80016c8:	9b01      	ldr	r3, [sp, #4]
 80016ca:	68da      	ldr	r2, [r3, #12]
 80016cc:	9b01      	ldr	r3, [sp, #4]
 80016ce:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 80016d0:	9b01      	ldr	r3, [sp, #4]
 80016d2:	2100      	movs	r1, #0
 80016d4:	0018      	movs	r0, r3
 80016d6:	f000 fae3 	bl	8001ca0 <chThdDequeueNextI>

  return Q_OK;
 80016da:	2300      	movs	r3, #0
}
 80016dc:	0018      	movs	r0, r3
 80016de:	b003      	add	sp, #12
 80016e0:	bd00      	pop	{pc}
 80016e2:	46c0      	nop			; (mov r8, r8)
	...

080016f0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 80016f0:	b500      	push	{lr}
 80016f2:	b085      	sub	sp, #20
 80016f4:	9001      	str	r0, [sp, #4]
 80016f6:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 80016f8:	f7ff ff2a 	bl	8001550 <chSysLock.lto_priv.171>
  if (iqp->q_notify != NULL) {
 80016fc:	9b01      	ldr	r3, [sp, #4]
 80016fe:	69db      	ldr	r3, [r3, #28]
 8001700:	2b00      	cmp	r3, #0
 8001702:	d014      	beq.n	800172e <chIQGetTimeout+0x3e>
    iqp->q_notify(iqp);
 8001704:	9b01      	ldr	r3, [sp, #4]
 8001706:	69db      	ldr	r3, [r3, #28]
 8001708:	9a01      	ldr	r2, [sp, #4]
 800170a:	0010      	movs	r0, r2
 800170c:	4798      	blx	r3
 800170e:	e00e      	b.n	800172e <chIQGetTimeout+0x3e>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001710:	9b01      	ldr	r3, [sp, #4]
 8001712:	9a00      	ldr	r2, [sp, #0]
 8001714:	0011      	movs	r1, r2
 8001716:	0018      	movs	r0, r3
 8001718:	f000 faa2 	bl	8001c60 <chThdEnqueueTimeoutS>
 800171c:	0003      	movs	r3, r0
 800171e:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 8001720:	9b03      	ldr	r3, [sp, #12]
 8001722:	2b00      	cmp	r3, #0
 8001724:	da03      	bge.n	800172e <chIQGetTimeout+0x3e>
      chSysUnlock();
 8001726:	f7ff ff1b 	bl	8001560 <chSysUnlock.lto_priv.165>
      return msg;
 800172a:	9b03      	ldr	r3, [sp, #12]
 800172c:	e022      	b.n	8001774 <chIQGetTimeout+0x84>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 800172e:	9b01      	ldr	r3, [sp, #4]
 8001730:	0018      	movs	r0, r3
 8001732:	f7ff ff2d 	bl	8001590 <chIQIsEmptyI>
 8001736:	1e03      	subs	r3, r0, #0
 8001738:	d1ea      	bne.n	8001710 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800173a:	9b01      	ldr	r3, [sp, #4]
 800173c:	689b      	ldr	r3, [r3, #8]
 800173e:	1e5a      	subs	r2, r3, #1
 8001740:	9b01      	ldr	r3, [sp, #4]
 8001742:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 8001744:	9b01      	ldr	r3, [sp, #4]
 8001746:	699b      	ldr	r3, [r3, #24]
 8001748:	1c59      	adds	r1, r3, #1
 800174a:	9a01      	ldr	r2, [sp, #4]
 800174c:	6191      	str	r1, [r2, #24]
 800174e:	220b      	movs	r2, #11
 8001750:	446a      	add	r2, sp
 8001752:	781b      	ldrb	r3, [r3, #0]
 8001754:	7013      	strb	r3, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001756:	9b01      	ldr	r3, [sp, #4]
 8001758:	699a      	ldr	r2, [r3, #24]
 800175a:	9b01      	ldr	r3, [sp, #4]
 800175c:	691b      	ldr	r3, [r3, #16]
 800175e:	429a      	cmp	r2, r3
 8001760:	d303      	bcc.n	800176a <chIQGetTimeout+0x7a>
    iqp->q_rdptr = iqp->q_buffer;
 8001762:	9b01      	ldr	r3, [sp, #4]
 8001764:	68da      	ldr	r2, [r3, #12]
 8001766:	9b01      	ldr	r3, [sp, #4]
 8001768:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 800176a:	f7ff fef9 	bl	8001560 <chSysUnlock.lto_priv.165>

  return (msg_t)b;
 800176e:	230b      	movs	r3, #11
 8001770:	446b      	add	r3, sp
 8001772:	781b      	ldrb	r3, [r3, #0]
}
 8001774:	0018      	movs	r0, r3
 8001776:	b005      	add	sp, #20
 8001778:	bd00      	pop	{pc}
 800177a:	46c0      	nop			; (mov r8, r8)
 800177c:	0000      	movs	r0, r0
	...

08001780 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001780:	b500      	push	{lr}
 8001782:	b087      	sub	sp, #28
 8001784:	9003      	str	r0, [sp, #12]
 8001786:	9102      	str	r1, [sp, #8]
 8001788:	9201      	str	r2, [sp, #4]
 800178a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800178c:	9b03      	ldr	r3, [sp, #12]
 800178e:	69db      	ldr	r3, [r3, #28]
 8001790:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8001792:	2300      	movs	r3, #0
 8001794:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8001796:	f7ff fedb 	bl	8001550 <chSysLock.lto_priv.171>
  while (true) {
    if (nfy != NULL) {
 800179a:	9b04      	ldr	r3, [sp, #16]
 800179c:	2b00      	cmp	r3, #0
 800179e:	d010      	beq.n	80017c2 <chIQReadTimeout+0x42>
      nfy(iqp);
 80017a0:	9a03      	ldr	r2, [sp, #12]
 80017a2:	9b04      	ldr	r3, [sp, #16]
 80017a4:	0010      	movs	r0, r2
 80017a6:	4798      	blx	r3
 80017a8:	e00b      	b.n	80017c2 <chIQReadTimeout+0x42>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 80017aa:	9b03      	ldr	r3, [sp, #12]
 80017ac:	9a00      	ldr	r2, [sp, #0]
 80017ae:	0011      	movs	r1, r2
 80017b0:	0018      	movs	r0, r3
 80017b2:	f000 fa55 	bl	8001c60 <chThdEnqueueTimeoutS>
 80017b6:	1e03      	subs	r3, r0, #0
 80017b8:	d003      	beq.n	80017c2 <chIQReadTimeout+0x42>
        chSysUnlock();
 80017ba:	f7ff fed1 	bl	8001560 <chSysUnlock.lto_priv.165>
        return r;
 80017be:	9b05      	ldr	r3, [sp, #20]
 80017c0:	e02e      	b.n	8001820 <chIQReadTimeout+0xa0>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 80017c2:	9b03      	ldr	r3, [sp, #12]
 80017c4:	0018      	movs	r0, r3
 80017c6:	f7ff fee3 	bl	8001590 <chIQIsEmptyI>
 80017ca:	1e03      	subs	r3, r0, #0
 80017cc:	d1ed      	bne.n	80017aa <chIQReadTimeout+0x2a>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80017ce:	9b03      	ldr	r3, [sp, #12]
 80017d0:	689b      	ldr	r3, [r3, #8]
 80017d2:	1e5a      	subs	r2, r3, #1
 80017d4:	9b03      	ldr	r3, [sp, #12]
 80017d6:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 80017d8:	9b02      	ldr	r3, [sp, #8]
 80017da:	1c5a      	adds	r2, r3, #1
 80017dc:	9202      	str	r2, [sp, #8]
 80017de:	9a03      	ldr	r2, [sp, #12]
 80017e0:	6992      	ldr	r2, [r2, #24]
 80017e2:	1c50      	adds	r0, r2, #1
 80017e4:	9903      	ldr	r1, [sp, #12]
 80017e6:	6188      	str	r0, [r1, #24]
 80017e8:	7812      	ldrb	r2, [r2, #0]
 80017ea:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 80017ec:	9b03      	ldr	r3, [sp, #12]
 80017ee:	699a      	ldr	r2, [r3, #24]
 80017f0:	9b03      	ldr	r3, [sp, #12]
 80017f2:	691b      	ldr	r3, [r3, #16]
 80017f4:	429a      	cmp	r2, r3
 80017f6:	d303      	bcc.n	8001800 <chIQReadTimeout+0x80>
      iqp->q_rdptr = iqp->q_buffer;
 80017f8:	9b03      	ldr	r3, [sp, #12]
 80017fa:	68da      	ldr	r2, [r3, #12]
 80017fc:	9b03      	ldr	r3, [sp, #12]
 80017fe:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8001800:	f7ff feae 	bl	8001560 <chSysUnlock.lto_priv.165>

    r++;
 8001804:	9b05      	ldr	r3, [sp, #20]
 8001806:	3301      	adds	r3, #1
 8001808:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	3b01      	subs	r3, #1
 800180e:	9301      	str	r3, [sp, #4]
 8001810:	9b01      	ldr	r3, [sp, #4]
 8001812:	2b00      	cmp	r3, #0
 8001814:	d101      	bne.n	800181a <chIQReadTimeout+0x9a>
      return r;
 8001816:	9b05      	ldr	r3, [sp, #20]
 8001818:	e002      	b.n	8001820 <chIQReadTimeout+0xa0>
    }

    chSysLock();
 800181a:	f7ff fe99 	bl	8001550 <chSysLock.lto_priv.171>
 800181e:	e7bc      	b.n	800179a <chIQReadTimeout+0x1a>
  }
}
 8001820:	0018      	movs	r0, r3
 8001822:	b007      	add	sp, #28
 8001824:	bd00      	pop	{pc}
 8001826:	46c0      	nop			; (mov r8, r8)
	...

08001830 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8001830:	b500      	push	{lr}
 8001832:	b085      	sub	sp, #20
 8001834:	9003      	str	r0, [sp, #12]
 8001836:	9102      	str	r1, [sp, #8]
 8001838:	9201      	str	r2, [sp, #4]
 800183a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 800183c:	9b03      	ldr	r3, [sp, #12]
 800183e:	0018      	movs	r0, r3
 8001840:	f7ff fe96 	bl	8001570 <chThdQueueObjectInit.lto_priv.161>
  oqp->q_counter = size;
 8001844:	9b03      	ldr	r3, [sp, #12]
 8001846:	9a01      	ldr	r2, [sp, #4]
 8001848:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800184a:	9b03      	ldr	r3, [sp, #12]
 800184c:	9a02      	ldr	r2, [sp, #8]
 800184e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8001850:	9b03      	ldr	r3, [sp, #12]
 8001852:	9a02      	ldr	r2, [sp, #8]
 8001854:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8001856:	9b03      	ldr	r3, [sp, #12]
 8001858:	9a02      	ldr	r2, [sp, #8]
 800185a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800185c:	9a02      	ldr	r2, [sp, #8]
 800185e:	9b01      	ldr	r3, [sp, #4]
 8001860:	18d2      	adds	r2, r2, r3
 8001862:	9b03      	ldr	r3, [sp, #12]
 8001864:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8001866:	9b03      	ldr	r3, [sp, #12]
 8001868:	9a00      	ldr	r2, [sp, #0]
 800186a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800186c:	9b03      	ldr	r3, [sp, #12]
 800186e:	9a06      	ldr	r2, [sp, #24]
 8001870:	621a      	str	r2, [r3, #32]
}
 8001872:	b005      	add	sp, #20
 8001874:	bd00      	pop	{pc}
 8001876:	46c0      	nop			; (mov r8, r8)
	...

08001880 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001880:	b500      	push	{lr}
 8001882:	b087      	sub	sp, #28
 8001884:	9003      	str	r0, [sp, #12]
 8001886:	9201      	str	r2, [sp, #4]
 8001888:	230b      	movs	r3, #11
 800188a:	446b      	add	r3, sp
 800188c:	1c0a      	adds	r2, r1, #0
 800188e:	701a      	strb	r2, [r3, #0]

  chSysLock();
 8001890:	f7ff fe5e 	bl	8001550 <chSysLock.lto_priv.171>
 8001894:	e00e      	b.n	80018b4 <chOQPutTimeout+0x34>
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001896:	9b03      	ldr	r3, [sp, #12]
 8001898:	9a01      	ldr	r2, [sp, #4]
 800189a:	0011      	movs	r1, r2
 800189c:	0018      	movs	r0, r3
 800189e:	f000 f9df 	bl	8001c60 <chThdEnqueueTimeoutS>
 80018a2:	0003      	movs	r3, r0
 80018a4:	9305      	str	r3, [sp, #20]
    if (msg < Q_OK) {
 80018a6:	9b05      	ldr	r3, [sp, #20]
 80018a8:	2b00      	cmp	r3, #0
 80018aa:	da03      	bge.n	80018b4 <chOQPutTimeout+0x34>
      chSysUnlock();
 80018ac:	f7ff fe58 	bl	8001560 <chSysUnlock.lto_priv.165>
      return msg;
 80018b0:	9b05      	ldr	r3, [sp, #20]
 80018b2:	e029      	b.n	8001908 <chOQPutTimeout+0x88>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 80018b4:	9b03      	ldr	r3, [sp, #12]
 80018b6:	0018      	movs	r0, r3
 80018b8:	f7ff feaa 	bl	8001610 <chOQIsFullI>
 80018bc:	1e03      	subs	r3, r0, #0
 80018be:	d1ea      	bne.n	8001896 <chOQPutTimeout+0x16>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80018c0:	9b03      	ldr	r3, [sp, #12]
 80018c2:	689b      	ldr	r3, [r3, #8]
 80018c4:	1e5a      	subs	r2, r3, #1
 80018c6:	9b03      	ldr	r3, [sp, #12]
 80018c8:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 80018ca:	9b03      	ldr	r3, [sp, #12]
 80018cc:	695b      	ldr	r3, [r3, #20]
 80018ce:	1c59      	adds	r1, r3, #1
 80018d0:	9a03      	ldr	r2, [sp, #12]
 80018d2:	6151      	str	r1, [r2, #20]
 80018d4:	220b      	movs	r2, #11
 80018d6:	446a      	add	r2, sp
 80018d8:	7812      	ldrb	r2, [r2, #0]
 80018da:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80018dc:	9b03      	ldr	r3, [sp, #12]
 80018de:	695a      	ldr	r2, [r3, #20]
 80018e0:	9b03      	ldr	r3, [sp, #12]
 80018e2:	691b      	ldr	r3, [r3, #16]
 80018e4:	429a      	cmp	r2, r3
 80018e6:	d303      	bcc.n	80018f0 <chOQPutTimeout+0x70>
    oqp->q_wrptr = oqp->q_buffer;
 80018e8:	9b03      	ldr	r3, [sp, #12]
 80018ea:	68da      	ldr	r2, [r3, #12]
 80018ec:	9b03      	ldr	r3, [sp, #12]
 80018ee:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80018f0:	9b03      	ldr	r3, [sp, #12]
 80018f2:	69db      	ldr	r3, [r3, #28]
 80018f4:	2b00      	cmp	r3, #0
 80018f6:	d004      	beq.n	8001902 <chOQPutTimeout+0x82>
    oqp->q_notify(oqp);
 80018f8:	9b03      	ldr	r3, [sp, #12]
 80018fa:	69db      	ldr	r3, [r3, #28]
 80018fc:	9a03      	ldr	r2, [sp, #12]
 80018fe:	0010      	movs	r0, r2
 8001900:	4798      	blx	r3
  }
  chSysUnlock();
 8001902:	f7ff fe2d 	bl	8001560 <chSysUnlock.lto_priv.165>

  return Q_OK;
 8001906:	2300      	movs	r3, #0
}
 8001908:	0018      	movs	r0, r3
 800190a:	b007      	add	sp, #28
 800190c:	bd00      	pop	{pc}
 800190e:	46c0      	nop			; (mov r8, r8)

08001910 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8001910:	b500      	push	{lr}
 8001912:	b085      	sub	sp, #20
 8001914:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
 8001916:	9b01      	ldr	r3, [sp, #4]
 8001918:	0018      	movs	r0, r3
 800191a:	f7ff fe61 	bl	80015e0 <chOQIsEmptyI>
 800191e:	1e03      	subs	r3, r0, #0
 8001920:	d002      	beq.n	8001928 <chOQGetI+0x18>
    return Q_EMPTY;
 8001922:	2303      	movs	r3, #3
 8001924:	425b      	negs	r3, r3
 8001926:	e01f      	b.n	8001968 <chOQGetI+0x58>
  }

  oqp->q_counter++;
 8001928:	9b01      	ldr	r3, [sp, #4]
 800192a:	689b      	ldr	r3, [r3, #8]
 800192c:	1c5a      	adds	r2, r3, #1
 800192e:	9b01      	ldr	r3, [sp, #4]
 8001930:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8001932:	9b01      	ldr	r3, [sp, #4]
 8001934:	699b      	ldr	r3, [r3, #24]
 8001936:	1c59      	adds	r1, r3, #1
 8001938:	9a01      	ldr	r2, [sp, #4]
 800193a:	6191      	str	r1, [r2, #24]
 800193c:	220f      	movs	r2, #15
 800193e:	446a      	add	r2, sp
 8001940:	781b      	ldrb	r3, [r3, #0]
 8001942:	7013      	strb	r3, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8001944:	9b01      	ldr	r3, [sp, #4]
 8001946:	699a      	ldr	r2, [r3, #24]
 8001948:	9b01      	ldr	r3, [sp, #4]
 800194a:	691b      	ldr	r3, [r3, #16]
 800194c:	429a      	cmp	r2, r3
 800194e:	d303      	bcc.n	8001958 <chOQGetI+0x48>
    oqp->q_rdptr = oqp->q_buffer;
 8001950:	9b01      	ldr	r3, [sp, #4]
 8001952:	68da      	ldr	r2, [r3, #12]
 8001954:	9b01      	ldr	r3, [sp, #4]
 8001956:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8001958:	9b01      	ldr	r3, [sp, #4]
 800195a:	2100      	movs	r1, #0
 800195c:	0018      	movs	r0, r3
 800195e:	f000 f99f 	bl	8001ca0 <chThdDequeueNextI>

  return (msg_t)b;
 8001962:	230f      	movs	r3, #15
 8001964:	446b      	add	r3, sp
 8001966:	781b      	ldrb	r3, [r3, #0]
}
 8001968:	0018      	movs	r0, r3
 800196a:	b005      	add	sp, #20
 800196c:	bd00      	pop	{pc}
 800196e:	46c0      	nop			; (mov r8, r8)

08001970 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001970:	b500      	push	{lr}
 8001972:	b087      	sub	sp, #28
 8001974:	9003      	str	r0, [sp, #12]
 8001976:	9102      	str	r1, [sp, #8]
 8001978:	9201      	str	r2, [sp, #4]
 800197a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 800197c:	9b03      	ldr	r3, [sp, #12]
 800197e:	69db      	ldr	r3, [r3, #28]
 8001980:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8001982:	2300      	movs	r3, #0
 8001984:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8001986:	f7ff fde3 	bl	8001550 <chSysLock.lto_priv.171>
 800198a:	e00b      	b.n	80019a4 <chOQWriteTimeout+0x34>
  while (true) {
    while (chOQIsFullI(oqp)) {
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800198c:	9b03      	ldr	r3, [sp, #12]
 800198e:	9a00      	ldr	r2, [sp, #0]
 8001990:	0011      	movs	r1, r2
 8001992:	0018      	movs	r0, r3
 8001994:	f000 f964 	bl	8001c60 <chThdEnqueueTimeoutS>
 8001998:	1e03      	subs	r3, r0, #0
 800199a:	d003      	beq.n	80019a4 <chOQWriteTimeout+0x34>
        chSysUnlock();
 800199c:	f7ff fde0 	bl	8001560 <chSysUnlock.lto_priv.165>
        return w;
 80019a0:	9b05      	ldr	r3, [sp, #20]
 80019a2:	e035      	b.n	8001a10 <chOQWriteTimeout+0xa0>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80019a4:	9b03      	ldr	r3, [sp, #12]
 80019a6:	0018      	movs	r0, r3
 80019a8:	f7ff fe32 	bl	8001610 <chOQIsFullI>
 80019ac:	1e03      	subs	r3, r0, #0
 80019ae:	d1ed      	bne.n	800198c <chOQWriteTimeout+0x1c>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 80019b0:	9b03      	ldr	r3, [sp, #12]
 80019b2:	689b      	ldr	r3, [r3, #8]
 80019b4:	1e5a      	subs	r2, r3, #1
 80019b6:	9b03      	ldr	r3, [sp, #12]
 80019b8:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 80019ba:	9b03      	ldr	r3, [sp, #12]
 80019bc:	695b      	ldr	r3, [r3, #20]
 80019be:	1c59      	adds	r1, r3, #1
 80019c0:	9a03      	ldr	r2, [sp, #12]
 80019c2:	6151      	str	r1, [r2, #20]
 80019c4:	9a02      	ldr	r2, [sp, #8]
 80019c6:	1c51      	adds	r1, r2, #1
 80019c8:	9102      	str	r1, [sp, #8]
 80019ca:	7812      	ldrb	r2, [r2, #0]
 80019cc:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80019ce:	9b03      	ldr	r3, [sp, #12]
 80019d0:	695a      	ldr	r2, [r3, #20]
 80019d2:	9b03      	ldr	r3, [sp, #12]
 80019d4:	691b      	ldr	r3, [r3, #16]
 80019d6:	429a      	cmp	r2, r3
 80019d8:	d303      	bcc.n	80019e2 <chOQWriteTimeout+0x72>
      oqp->q_wrptr = oqp->q_buffer;
 80019da:	9b03      	ldr	r3, [sp, #12]
 80019dc:	68da      	ldr	r2, [r3, #12]
 80019de:	9b03      	ldr	r3, [sp, #12]
 80019e0:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80019e2:	9b04      	ldr	r3, [sp, #16]
 80019e4:	2b00      	cmp	r3, #0
 80019e6:	d003      	beq.n	80019f0 <chOQWriteTimeout+0x80>
      nfy(oqp);
 80019e8:	9a03      	ldr	r2, [sp, #12]
 80019ea:	9b04      	ldr	r3, [sp, #16]
 80019ec:	0010      	movs	r0, r2
 80019ee:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80019f0:	f7ff fdb6 	bl	8001560 <chSysUnlock.lto_priv.165>

    w++;
 80019f4:	9b05      	ldr	r3, [sp, #20]
 80019f6:	3301      	adds	r3, #1
 80019f8:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80019fa:	9b01      	ldr	r3, [sp, #4]
 80019fc:	3b01      	subs	r3, #1
 80019fe:	9301      	str	r3, [sp, #4]
 8001a00:	9b01      	ldr	r3, [sp, #4]
 8001a02:	2b00      	cmp	r3, #0
 8001a04:	d101      	bne.n	8001a0a <chOQWriteTimeout+0x9a>
      return w;
 8001a06:	9b05      	ldr	r3, [sp, #20]
 8001a08:	e002      	b.n	8001a10 <chOQWriteTimeout+0xa0>
    }
    chSysLock();
 8001a0a:	f7ff fda1 	bl	8001550 <chSysLock.lto_priv.171>
 8001a0e:	e7c9      	b.n	80019a4 <chOQWriteTimeout+0x34>
  }
}
 8001a10:	0018      	movs	r0, r3
 8001a12:	b007      	add	sp, #28
 8001a14:	bd00      	pop	{pc}
 8001a16:	46c0      	nop			; (mov r8, r8)
	...

08001a20 <port_lock.lto_priv.185>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001a20:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001a22:	4770      	bx	lr
	...

08001a30 <port_unlock.lto_priv.179>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a30:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001a32:	4770      	bx	lr
	...

08001a40 <chSysLock.lto_priv.172>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001a40:	b510      	push	{r4, lr}

  port_lock();
 8001a42:	f7ff ffed 	bl	8001a20 <port_lock.lto_priv.185>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001a46:	bd10      	pop	{r4, pc}
	...

08001a50 <chSysUnlock.lto_priv.166>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001a50:	b510      	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001a52:	f7ff ffed 	bl	8001a30 <port_unlock.lto_priv.179>
}
 8001a56:	bd10      	pop	{r4, pc}
	...

08001a60 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001a60:	4b06      	ldr	r3, [pc, #24]	; (8001a7c <_core_init+0x1c>)
 8001a62:	3307      	adds	r3, #7
 8001a64:	2207      	movs	r2, #7
 8001a66:	4393      	bics	r3, r2
 8001a68:	001a      	movs	r2, r3
 8001a6a:	4b05      	ldr	r3, [pc, #20]	; (8001a80 <_core_init+0x20>)
 8001a6c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001a6e:	4b05      	ldr	r3, [pc, #20]	; (8001a84 <_core_init+0x24>)
 8001a70:	2207      	movs	r2, #7
 8001a72:	4393      	bics	r3, r2
 8001a74:	001a      	movs	r2, r3
 8001a76:	4b04      	ldr	r3, [pc, #16]	; (8001a88 <_core_init+0x28>)
 8001a78:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 8001a7a:	4770      	bx	lr
 8001a7c:	20000a60 	.word	0x20000a60
 8001a80:	200007b8 	.word	0x200007b8
 8001a84:	20001800 	.word	0x20001800
 8001a88:	200007bc 	.word	0x200007bc
 8001a8c:	00000000 	.word	0x00000000

08001a90 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8001a90:	b500      	push	{lr}
 8001a92:	b085      	sub	sp, #20
 8001a94:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8001a96:	f7ff ffd3 	bl	8001a40 <chSysLock.lto_priv.172>
  p = chCoreAllocI(size);
 8001a9a:	9b01      	ldr	r3, [sp, #4]
 8001a9c:	0018      	movs	r0, r3
 8001a9e:	f000 f80f 	bl	8001ac0 <chCoreAllocI>
 8001aa2:	0003      	movs	r3, r0
 8001aa4:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8001aa6:	f7ff ffd3 	bl	8001a50 <chSysUnlock.lto_priv.166>

  return p;
 8001aaa:	9b03      	ldr	r3, [sp, #12]
}
 8001aac:	0018      	movs	r0, r3
 8001aae:	b005      	add	sp, #20
 8001ab0:	bd00      	pop	{pc}
 8001ab2:	46c0      	nop			; (mov r8, r8)
	...

08001ac0 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8001ac0:	b084      	sub	sp, #16
 8001ac2:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001ac4:	9b01      	ldr	r3, [sp, #4]
 8001ac6:	3307      	adds	r3, #7
 8001ac8:	2207      	movs	r2, #7
 8001aca:	4393      	bics	r3, r2
 8001acc:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8001ace:	4b0c      	ldr	r3, [pc, #48]	; (8001b00 <chCoreAllocI+0x40>)
 8001ad0:	681b      	ldr	r3, [r3, #0]
 8001ad2:	001a      	movs	r2, r3
 8001ad4:	4b0b      	ldr	r3, [pc, #44]	; (8001b04 <chCoreAllocI+0x44>)
 8001ad6:	681b      	ldr	r3, [r3, #0]
 8001ad8:	1ad3      	subs	r3, r2, r3
 8001ada:	001a      	movs	r2, r3
 8001adc:	9b01      	ldr	r3, [sp, #4]
 8001ade:	429a      	cmp	r2, r3
 8001ae0:	d201      	bcs.n	8001ae6 <chCoreAllocI+0x26>
  /*lint -restore*/
    return NULL;
 8001ae2:	2300      	movs	r3, #0
 8001ae4:	e009      	b.n	8001afa <chCoreAllocI+0x3a>
  }
  p = nextmem;
 8001ae6:	4b07      	ldr	r3, [pc, #28]	; (8001b04 <chCoreAllocI+0x44>)
 8001ae8:	681b      	ldr	r3, [r3, #0]
 8001aea:	9303      	str	r3, [sp, #12]
  nextmem += size;
 8001aec:	4b05      	ldr	r3, [pc, #20]	; (8001b04 <chCoreAllocI+0x44>)
 8001aee:	681a      	ldr	r2, [r3, #0]
 8001af0:	9b01      	ldr	r3, [sp, #4]
 8001af2:	18d2      	adds	r2, r2, r3
 8001af4:	4b03      	ldr	r3, [pc, #12]	; (8001b04 <chCoreAllocI+0x44>)
 8001af6:	601a      	str	r2, [r3, #0]

  return p;
 8001af8:	9b03      	ldr	r3, [sp, #12]
}
 8001afa:	0018      	movs	r0, r3
 8001afc:	b004      	add	sp, #16
 8001afe:	4770      	bx	lr
 8001b00:	200007bc 	.word	0x200007bc
 8001b04:	200007b8 	.word	0x200007b8
	...

08001b10 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8001b10:	b510      	push	{r4, lr}

  default_heap.h_provider = chCoreAlloc;
 8001b12:	4b07      	ldr	r3, [pc, #28]	; (8001b30 <_heap_init+0x20>)
 8001b14:	4a07      	ldr	r2, [pc, #28]	; (8001b34 <_heap_init+0x24>)
 8001b16:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8001b18:	4b05      	ldr	r3, [pc, #20]	; (8001b30 <_heap_init+0x20>)
 8001b1a:	2200      	movs	r2, #0
 8001b1c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8001b1e:	4b04      	ldr	r3, [pc, #16]	; (8001b30 <_heap_init+0x20>)
 8001b20:	2200      	movs	r2, #0
 8001b22:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8001b24:	4b04      	ldr	r3, [pc, #16]	; (8001b38 <_heap_init+0x28>)
 8001b26:	0018      	movs	r0, r3
 8001b28:	f000 f8e2 	bl	8001cf0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 8001b2c:	bd10      	pop	{r4, pc}
 8001b2e:	46c0      	nop			; (mov r8, r8)
 8001b30:	200007c0 	.word	0x200007c0
 8001b34:	08001a91 	.word	0x08001a91
 8001b38:	200007d0 	.word	0x200007d0
 8001b3c:	00000000 	.word	0x00000000

08001b40 <port_lock.lto_priv.187>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001b40:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001b42:	4770      	bx	lr
	...

08001b50 <port_unlock.lto_priv.181>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001b50:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001b52:	4770      	bx	lr
	...

08001b60 <port_lock_from_isr>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001b60:	b510      	push	{r4, lr}

  port_lock();
 8001b62:	f7ff ffed 	bl	8001b40 <port_lock.lto_priv.187>
}
 8001b66:	bd10      	pop	{r4, pc}
	...

08001b70 <port_unlock_from_isr>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001b70:	b510      	push	{r4, lr}

  port_unlock();
 8001b72:	f7ff ffed 	bl	8001b50 <port_unlock.lto_priv.181>
}
 8001b76:	bd10      	pop	{r4, pc}
	...

08001b80 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8001b80:	b510      	push	{r4, lr}
 8001b82:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001b84:	f3ef 8309 	mrs	r3, PSP
 8001b88:	001c      	movs	r4, r3
  return(result);
 8001b8a:	0023      	movs	r3, r4
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 8001b8c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8001b8e:	9b01      	ldr	r3, [sp, #4]
 8001b90:	3320      	adds	r3, #32
 8001b92:	9301      	str	r3, [sp, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8001b94:	9b01      	ldr	r3, [sp, #4]
 8001b96:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001b98:	9b00      	ldr	r3, [sp, #0]
 8001b9a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8001b9e:	f7ff ffe7 	bl	8001b70 <port_unlock_from_isr>
}
 8001ba2:	b002      	add	sp, #8
 8001ba4:	bd10      	pop	{r4, pc}
 8001ba6:	46c0      	nop			; (mov r8, r8)
	...

08001bb0 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 8001bb0:	b510      	push	{r4, lr}
 8001bb2:	b084      	sub	sp, #16
 8001bb4:	9001      	str	r0, [sp, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8001bb6:	9b01      	ldr	r3, [sp, #4]
 8001bb8:	330f      	adds	r3, #15
 8001bba:	d01d      	beq.n	8001bf8 <_port_irq_epilogue+0x48>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 8001bbc:	f7ff ffd0 	bl	8001b60 <port_lock_from_isr>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001bc0:	f3ef 8309 	mrs	r3, PSP
 8001bc4:	001c      	movs	r4, r3
  return(result);
 8001bc6:	0023      	movs	r3, r4

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8001bc8:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001bca:	9b03      	ldr	r3, [sp, #12]
 8001bcc:	3b20      	subs	r3, #32
 8001bce:	9303      	str	r3, [sp, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8001bd0:	9b03      	ldr	r3, [sp, #12]
 8001bd2:	9302      	str	r3, [sp, #8]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001bd4:	9b02      	ldr	r3, [sp, #8]
 8001bd6:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001bda:	9b03      	ldr	r3, [sp, #12]
 8001bdc:	2280      	movs	r2, #128	; 0x80
 8001bde:	0452      	lsls	r2, r2, #17
 8001be0:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001be2:	f000 fcad 	bl	8002540 <chSchIsPreemptionRequired>
 8001be6:	1e03      	subs	r3, r0, #0
 8001be8:	d003      	beq.n	8001bf2 <_port_irq_epilogue+0x42>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001bea:	9b03      	ldr	r3, [sp, #12]
 8001bec:	4a03      	ldr	r2, [pc, #12]	; (8001bfc <_port_irq_epilogue+0x4c>)
 8001bee:	619a      	str	r2, [r3, #24]
 8001bf0:	e002      	b.n	8001bf8 <_port_irq_epilogue+0x48>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001bf2:	9b03      	ldr	r3, [sp, #12]
 8001bf4:	4a02      	ldr	r2, [pc, #8]	; (8001c00 <_port_irq_epilogue+0x50>)
 8001bf6:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8001bf8:	b004      	add	sp, #16
 8001bfa:	bd10      	pop	{r4, pc}
 8001bfc:	080001bd 	.word	0x080001bd
 8001c00:	080001c0 	.word	0x080001c0
	...

08001c10 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8001c10:	4770      	bx	lr
 8001c12:	46c0      	nop			; (mov r8, r8)
	...

08001c20 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001c20:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8001c22:	f7ff fff5 	bl	8001c10 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8001c26:	f7ff fae3 	bl	80011f0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001c2a:	4b06      	ldr	r3, [pc, #24]	; (8001c44 <halInit+0x24>)
 8001c2c:	0018      	movs	r0, r3
 8001c2e:	f7ff fc1f 	bl	8001470 <_pal_lld_init>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8001c32:	f7ff f86d 	bl	8000d10 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8001c36:	f7ff f9db 	bl	8000ff0 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8001c3a:	f7ff f831 	bl	8000ca0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001c3e:	f000 f807 	bl	8001c50 <stInit>
#endif
}
 8001c42:	bd10      	pop	{r4, pc}
 8001c44:	08003000 	.word	0x08003000
	...

08001c50 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8001c50:	b510      	push	{r4, lr}

  st_lld_init();
 8001c52:	f7ff fbcd 	bl	80013f0 <st_lld_init>
}
 8001c56:	bd10      	pop	{r4, pc}
	...

08001c60 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001c60:	b500      	push	{lr}
 8001c62:	b083      	sub	sp, #12
 8001c64:	9001      	str	r0, [sp, #4]
 8001c66:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8001c68:	9b00      	ldr	r3, [sp, #0]
 8001c6a:	2b00      	cmp	r3, #0
 8001c6c:	d102      	bne.n	8001c74 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 8001c6e:	2301      	movs	r3, #1
 8001c70:	425b      	negs	r3, r3
 8001c72:	e00c      	b.n	8001c8e <chThdEnqueueTimeoutS+0x2e>
  }

  queue_insert(currp, tqp);
 8001c74:	4b07      	ldr	r3, [pc, #28]	; (8001c94 <chThdEnqueueTimeoutS+0x34>)
 8001c76:	699b      	ldr	r3, [r3, #24]
 8001c78:	9a01      	ldr	r2, [sp, #4]
 8001c7a:	0011      	movs	r1, r2
 8001c7c:	0018      	movs	r0, r3
 8001c7e:	f000 fd0f 	bl	80026a0 <queue_insert.lto_priv.237>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001c82:	9b00      	ldr	r3, [sp, #0]
 8001c84:	0019      	movs	r1, r3
 8001c86:	2004      	movs	r0, #4
 8001c88:	f000 fbf2 	bl	8002470 <chSchGoSleepTimeoutS>
 8001c8c:	0003      	movs	r3, r0
}
 8001c8e:	0018      	movs	r0, r3
 8001c90:	b003      	add	sp, #12
 8001c92:	bd00      	pop	{pc}
 8001c94:	20000668 	.word	0x20000668
	...

08001ca0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001ca0:	b500      	push	{lr}
 8001ca2:	b083      	sub	sp, #12
 8001ca4:	9001      	str	r0, [sp, #4]
 8001ca6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8001ca8:	9b01      	ldr	r3, [sp, #4]
 8001caa:	0018      	movs	r0, r3
 8001cac:	f000 fcd8 	bl	8002660 <queue_notempty.lto_priv.231>
 8001cb0:	1e03      	subs	r3, r0, #0
 8001cb2:	d005      	beq.n	8001cc0 <chThdDequeueNextI+0x20>
    chThdDoDequeueNextI(tqp, msg);
 8001cb4:	9a00      	ldr	r2, [sp, #0]
 8001cb6:	9b01      	ldr	r3, [sp, #4]
 8001cb8:	0011      	movs	r1, r2
 8001cba:	0018      	movs	r0, r3
 8001cbc:	f000 fd40 	bl	8002740 <chThdDoDequeueNextI.lto_priv.239>
  }
}
 8001cc0:	b003      	add	sp, #12
 8001cc2:	bd00      	pop	{pc}
	...

08001cd0 <queue_init.lto_priv.235>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001cd0:	b082      	sub	sp, #8
 8001cd2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001cd4:	9b01      	ldr	r3, [sp, #4]
 8001cd6:	9a01      	ldr	r2, [sp, #4]
 8001cd8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001cda:	9b01      	ldr	r3, [sp, #4]
 8001cdc:	9a01      	ldr	r2, [sp, #4]
 8001cde:	605a      	str	r2, [r3, #4]
}
 8001ce0:	b002      	add	sp, #8
 8001ce2:	4770      	bx	lr
	...

08001cf0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001cf0:	b500      	push	{lr}
 8001cf2:	b083      	sub	sp, #12
 8001cf4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8001cf6:	9b01      	ldr	r3, [sp, #4]
 8001cf8:	0018      	movs	r0, r3
 8001cfa:	f7ff ffe9 	bl	8001cd0 <queue_init.lto_priv.235>
  mp->m_owner = NULL;
 8001cfe:	9b01      	ldr	r3, [sp, #4]
 8001d00:	2200      	movs	r2, #0
 8001d02:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8001d04:	b003      	add	sp, #12
 8001d06:	bd00      	pop	{pc}
	...

08001d10 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001d10:	b500      	push	{lr}
 8001d12:	b085      	sub	sp, #20
 8001d14:	9001      	str	r0, [sp, #4]
 8001d16:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8001d18:	9b01      	ldr	r3, [sp, #4]
 8001d1a:	681b      	ldr	r3, [r3, #0]
 8001d1c:	9303      	str	r3, [sp, #12]
 8001d1e:	e019      	b.n	8001d54 <chEvtBroadcastFlagsI+0x44>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
 8001d20:	9b03      	ldr	r3, [sp, #12]
 8001d22:	68da      	ldr	r2, [r3, #12]
 8001d24:	9b00      	ldr	r3, [sp, #0]
 8001d26:	431a      	orrs	r2, r3
 8001d28:	9b03      	ldr	r3, [sp, #12]
 8001d2a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001d2c:	9b00      	ldr	r3, [sp, #0]
 8001d2e:	2b00      	cmp	r3, #0
 8001d30:	d005      	beq.n	8001d3e <chEvtBroadcastFlagsI+0x2e>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8001d32:	9b03      	ldr	r3, [sp, #12]
 8001d34:	68da      	ldr	r2, [r3, #12]
 8001d36:	9b03      	ldr	r3, [sp, #12]
 8001d38:	691b      	ldr	r3, [r3, #16]
 8001d3a:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001d3c:	d007      	beq.n	8001d4e <chEvtBroadcastFlagsI+0x3e>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8001d3e:	9b03      	ldr	r3, [sp, #12]
 8001d40:	685a      	ldr	r2, [r3, #4]
 8001d42:	9b03      	ldr	r3, [sp, #12]
 8001d44:	689b      	ldr	r3, [r3, #8]
 8001d46:	0019      	movs	r1, r3
 8001d48:	0010      	movs	r0, r2
 8001d4a:	f000 f809 	bl	8001d60 <chEvtSignalI>
    }
    elp = elp->el_next;
 8001d4e:	9b03      	ldr	r3, [sp, #12]
 8001d50:	681b      	ldr	r3, [r3, #0]
 8001d52:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001d54:	9a03      	ldr	r2, [sp, #12]
 8001d56:	9b01      	ldr	r3, [sp, #4]
 8001d58:	429a      	cmp	r2, r3
 8001d5a:	d1e1      	bne.n	8001d20 <chEvtBroadcastFlagsI+0x10>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 8001d5c:	b005      	add	sp, #20
 8001d5e:	bd00      	pop	{pc}

08001d60 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8001d60:	b500      	push	{lr}
 8001d62:	b083      	sub	sp, #12
 8001d64:	9001      	str	r0, [sp, #4]
 8001d66:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001d68:	9b01      	ldr	r3, [sp, #4]
 8001d6a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001d6c:	9b00      	ldr	r3, [sp, #0]
 8001d6e:	431a      	orrs	r2, r3
 8001d70:	9b01      	ldr	r3, [sp, #4]
 8001d72:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001d74:	9b01      	ldr	r3, [sp, #4]
 8001d76:	7f1b      	ldrb	r3, [r3, #28]
 8001d78:	2b0a      	cmp	r3, #10
 8001d7a:	d105      	bne.n	8001d88 <chEvtSignalI+0x28>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8001d7c:	9b01      	ldr	r3, [sp, #4]
 8001d7e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001d80:	9b01      	ldr	r3, [sp, #4]
 8001d82:	6a1b      	ldr	r3, [r3, #32]
 8001d84:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001d86:	d10c      	bne.n	8001da2 <chEvtSignalI+0x42>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001d88:	9b01      	ldr	r3, [sp, #4]
 8001d8a:	7f1b      	ldrb	r3, [r3, #28]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8001d8c:	2b0b      	cmp	r3, #11
 8001d8e:	d10f      	bne.n	8001db0 <chEvtSignalI+0x50>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001d90:	9b01      	ldr	r3, [sp, #4]
 8001d92:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001d94:	9b01      	ldr	r3, [sp, #4]
 8001d96:	6a1b      	ldr	r3, [r3, #32]
 8001d98:	401a      	ands	r2, r3
 8001d9a:	9b01      	ldr	r3, [sp, #4]
 8001d9c:	6a1b      	ldr	r3, [r3, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001d9e:	429a      	cmp	r2, r3
 8001da0:	d106      	bne.n	8001db0 <chEvtSignalI+0x50>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001da2:	9b01      	ldr	r3, [sp, #4]
 8001da4:	2200      	movs	r2, #0
 8001da6:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8001da8:	9b01      	ldr	r3, [sp, #4]
 8001daa:	0018      	movs	r0, r3
 8001dac:	f000 fae0 	bl	8002370 <chSchReadyI>
  }
}
 8001db0:	b003      	add	sp, #12
 8001db2:	bd00      	pop	{pc}
	...

08001dc0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001dc0:	4770      	bx	lr
 8001dc2:	46c0      	nop			; (mov r8, r8)
	...

08001dd0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001dd0:	4770      	bx	lr
 8001dd2:	46c0      	nop			; (mov r8, r8)
	...

08001de0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001de0:	e7fe      	b.n	8001de0 <__default_exit>
 8001de2:	46c0      	nop			; (mov r8, r8)
	...

08001df0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001df0:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001df2:	4b16      	ldr	r3, [pc, #88]	; (8001e4c <__init_ram_areas+0x5c>)
 8001df4:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8001df6:	9b03      	ldr	r3, [sp, #12]
 8001df8:	681b      	ldr	r3, [r3, #0]
 8001dfa:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 8001dfc:	9b03      	ldr	r3, [sp, #12]
 8001dfe:	685b      	ldr	r3, [r3, #4]
 8001e00:	9301      	str	r3, [sp, #4]
 8001e02:	e009      	b.n	8001e18 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8001e04:	9b02      	ldr	r3, [sp, #8]
 8001e06:	681a      	ldr	r2, [r3, #0]
 8001e08:	9b01      	ldr	r3, [sp, #4]
 8001e0a:	601a      	str	r2, [r3, #0]
      p++;
 8001e0c:	9b01      	ldr	r3, [sp, #4]
 8001e0e:	3304      	adds	r3, #4
 8001e10:	9301      	str	r3, [sp, #4]
      tp++;
 8001e12:	9b02      	ldr	r3, [sp, #8]
 8001e14:	3304      	adds	r3, #4
 8001e16:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001e18:	9b03      	ldr	r3, [sp, #12]
 8001e1a:	689a      	ldr	r2, [r3, #8]
 8001e1c:	9b01      	ldr	r3, [sp, #4]
 8001e1e:	429a      	cmp	r2, r3
 8001e20:	d8f0      	bhi.n	8001e04 <__init_ram_areas+0x14>
 8001e22:	e005      	b.n	8001e30 <__init_ram_areas+0x40>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001e24:	9b01      	ldr	r3, [sp, #4]
 8001e26:	2200      	movs	r2, #0
 8001e28:	601a      	str	r2, [r3, #0]
      p++;
 8001e2a:	9b01      	ldr	r3, [sp, #4]
 8001e2c:	3304      	adds	r3, #4
 8001e2e:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001e30:	9b03      	ldr	r3, [sp, #12]
 8001e32:	68da      	ldr	r2, [r3, #12]
 8001e34:	9b01      	ldr	r3, [sp, #4]
 8001e36:	429a      	cmp	r2, r3
 8001e38:	d8f4      	bhi.n	8001e24 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 8001e3a:	9b03      	ldr	r3, [sp, #12]
 8001e3c:	3310      	adds	r3, #16
 8001e3e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001e40:	9a03      	ldr	r2, [sp, #12]
 8001e42:	4b03      	ldr	r3, [pc, #12]	; (8001e50 <__init_ram_areas+0x60>)
 8001e44:	429a      	cmp	r2, r3
 8001e46:	d3d6      	bcc.n	8001df6 <__init_ram_areas+0x6>
#endif
}
 8001e48:	b004      	add	sp, #16
 8001e4a:	4770      	bx	lr
 8001e4c:	08002f40 	.word	0x08002f40
 8001e50:	08002fc0 	.word	0x08002fc0
	...

08001e60 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001e60:	e7fe      	b.n	8001e60 <BusFault_Handler>
 8001e62:	46c0      	nop			; (mov r8, r8)
	...

08001e70 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001e70:	b530      	push	{r4, r5, lr}
 8001e72:	b083      	sub	sp, #12
 8001e74:	0002      	movs	r2, r0
 8001e76:	9100      	str	r1, [sp, #0]
 8001e78:	466b      	mov	r3, sp
 8001e7a:	3307      	adds	r3, #7
 8001e7c:	701a      	strb	r2, [r3, #0]
  if((int32_t)(IRQn) < 0) {
 8001e7e:	466b      	mov	r3, sp
 8001e80:	3307      	adds	r3, #7
 8001e82:	781b      	ldrb	r3, [r3, #0]
 8001e84:	2b7f      	cmp	r3, #127	; 0x7f
 8001e86:	d936      	bls.n	8001ef6 <NVIC_SetPriority+0x86>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001e88:	4c32      	ldr	r4, [pc, #200]	; (8001f54 <NVIC_SetPriority+0xe4>)
 8001e8a:	466b      	mov	r3, sp
 8001e8c:	3307      	adds	r3, #7
 8001e8e:	781b      	ldrb	r3, [r3, #0]
 8001e90:	001a      	movs	r2, r3
 8001e92:	230f      	movs	r3, #15
 8001e94:	4013      	ands	r3, r2
 8001e96:	3b08      	subs	r3, #8
 8001e98:	0899      	lsrs	r1, r3, #2
 8001e9a:	4a2e      	ldr	r2, [pc, #184]	; (8001f54 <NVIC_SetPriority+0xe4>)
 8001e9c:	466b      	mov	r3, sp
 8001e9e:	3307      	adds	r3, #7
 8001ea0:	781b      	ldrb	r3, [r3, #0]
 8001ea2:	0018      	movs	r0, r3
 8001ea4:	230f      	movs	r3, #15
 8001ea6:	4003      	ands	r3, r0
 8001ea8:	3b08      	subs	r3, #8
 8001eaa:	089b      	lsrs	r3, r3, #2
 8001eac:	3306      	adds	r3, #6
 8001eae:	009b      	lsls	r3, r3, #2
 8001eb0:	18d3      	adds	r3, r2, r3
 8001eb2:	3304      	adds	r3, #4
 8001eb4:	681b      	ldr	r3, [r3, #0]
 8001eb6:	466a      	mov	r2, sp
 8001eb8:	3207      	adds	r2, #7
 8001eba:	7812      	ldrb	r2, [r2, #0]
 8001ebc:	0010      	movs	r0, r2
 8001ebe:	2203      	movs	r2, #3
 8001ec0:	4002      	ands	r2, r0
 8001ec2:	00d2      	lsls	r2, r2, #3
 8001ec4:	20ff      	movs	r0, #255	; 0xff
 8001ec6:	4090      	lsls	r0, r2
 8001ec8:	0002      	movs	r2, r0
 8001eca:	43d2      	mvns	r2, r2
 8001ecc:	401a      	ands	r2, r3
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8001ece:	9b00      	ldr	r3, [sp, #0]
 8001ed0:	019b      	lsls	r3, r3, #6
 8001ed2:	20ff      	movs	r0, #255	; 0xff
 8001ed4:	4018      	ands	r0, r3
 8001ed6:	466b      	mov	r3, sp
 8001ed8:	3307      	adds	r3, #7
 8001eda:	781b      	ldrb	r3, [r3, #0]
 8001edc:	001d      	movs	r5, r3
 8001ede:	2303      	movs	r3, #3
 8001ee0:	402b      	ands	r3, r5
 8001ee2:	00db      	lsls	r3, r3, #3
 8001ee4:	4098      	lsls	r0, r3
 8001ee6:	0003      	movs	r3, r0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001ee8:	431a      	orrs	r2, r3
 8001eea:	1d8b      	adds	r3, r1, #6
 8001eec:	009b      	lsls	r3, r3, #2
 8001eee:	18e3      	adds	r3, r4, r3
 8001ef0:	3304      	adds	r3, #4
 8001ef2:	601a      	str	r2, [r3, #0]
 8001ef4:	e02b      	b.n	8001f4e <NVIC_SetPriority+0xde>
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001ef6:	4c18      	ldr	r4, [pc, #96]	; (8001f58 <NVIC_SetPriority+0xe8>)
 8001ef8:	466b      	mov	r3, sp
 8001efa:	3307      	adds	r3, #7
 8001efc:	781b      	ldrb	r3, [r3, #0]
 8001efe:	b25b      	sxtb	r3, r3
 8001f00:	089b      	lsrs	r3, r3, #2
 8001f02:	4915      	ldr	r1, [pc, #84]	; (8001f58 <NVIC_SetPriority+0xe8>)
 8001f04:	466a      	mov	r2, sp
 8001f06:	3207      	adds	r2, #7
 8001f08:	7812      	ldrb	r2, [r2, #0]
 8001f0a:	b252      	sxtb	r2, r2
 8001f0c:	0892      	lsrs	r2, r2, #2
 8001f0e:	32c0      	adds	r2, #192	; 0xc0
 8001f10:	0092      	lsls	r2, r2, #2
 8001f12:	5852      	ldr	r2, [r2, r1]
 8001f14:	4669      	mov	r1, sp
 8001f16:	3107      	adds	r1, #7
 8001f18:	7809      	ldrb	r1, [r1, #0]
 8001f1a:	0008      	movs	r0, r1
 8001f1c:	2103      	movs	r1, #3
 8001f1e:	4001      	ands	r1, r0
 8001f20:	00c9      	lsls	r1, r1, #3
 8001f22:	20ff      	movs	r0, #255	; 0xff
 8001f24:	4088      	lsls	r0, r1
 8001f26:	0001      	movs	r1, r0
 8001f28:	43c9      	mvns	r1, r1
 8001f2a:	4011      	ands	r1, r2
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8001f2c:	9a00      	ldr	r2, [sp, #0]
 8001f2e:	0192      	lsls	r2, r2, #6
 8001f30:	20ff      	movs	r0, #255	; 0xff
 8001f32:	4010      	ands	r0, r2
 8001f34:	466a      	mov	r2, sp
 8001f36:	3207      	adds	r2, #7
 8001f38:	7812      	ldrb	r2, [r2, #0]
 8001f3a:	0015      	movs	r5, r2
 8001f3c:	2203      	movs	r2, #3
 8001f3e:	402a      	ands	r2, r5
 8001f40:	00d2      	lsls	r2, r2, #3
 8001f42:	4090      	lsls	r0, r2
 8001f44:	0002      	movs	r2, r0
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001f46:	430a      	orrs	r2, r1
 8001f48:	33c0      	adds	r3, #192	; 0xc0
 8001f4a:	009b      	lsls	r3, r3, #2
 8001f4c:	511a      	str	r2, [r3, r4]
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8001f4e:	b003      	add	sp, #12
 8001f50:	bd30      	pop	{r4, r5, pc}
 8001f52:	46c0      	nop			; (mov r8, r8)
 8001f54:	e000ed00 	.word	0xe000ed00
 8001f58:	e000e100 	.word	0xe000e100
 8001f5c:	00000000 	.word	0x00000000

08001f60 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8001f60:	b510      	push	{r4, lr}

  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8001f62:	2302      	movs	r3, #2
 8001f64:	425b      	negs	r3, r3
 8001f66:	2100      	movs	r1, #0
 8001f68:	0018      	movs	r0, r3
 8001f6a:	f7ff ff81 	bl	8001e70 <NVIC_SetPriority>
}
 8001f6e:	bd10      	pop	{r4, pc}

08001f70 <port_lock.lto_priv.247>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001f70:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001f72:	4770      	bx	lr
	...

08001f80 <port_unlock.lto_priv.244>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001f80:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001f82:	4770      	bx	lr
	...

08001f90 <port_lock_from_isr.lto_priv.256>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001f90:	b510      	push	{r4, lr}

  port_lock();
 8001f92:	f7ff ffed 	bl	8001f70 <port_lock.lto_priv.247>
}
 8001f96:	bd10      	pop	{r4, pc}
	...

08001fa0 <port_unlock_from_isr.lto_priv.254>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001fa0:	b510      	push	{r4, lr}

  port_unlock();
 8001fa2:	f7ff ffed 	bl	8001f80 <port_unlock.lto_priv.244>
}
 8001fa6:	bd10      	pop	{r4, pc}
	...

08001fb0 <port_enable>:
 8001fb0:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 8001fb2:	4770      	bx	lr
	...

08001fc0 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8001fc0:	4770      	bx	lr
 8001fc2:	46c0      	nop			; (mov r8, r8)
	...

08001fd0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8001fd0:	b510      	push	{r4, lr}

  _dbg_check_enable();
  port_enable();
 8001fd2:	f7ff ffed 	bl	8001fb0 <port_enable>
}
 8001fd6:	bd10      	pop	{r4, pc}
	...

08001fe0 <chSysLockFromISR.lto_priv.252>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001fe0:	b510      	push	{r4, lr}

  port_lock_from_isr();
 8001fe2:	f7ff ffd5 	bl	8001f90 <port_lock_from_isr.lto_priv.256>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001fe6:	bd10      	pop	{r4, pc}
	...

08001ff0 <chSysUnlockFromISR.lto_priv.250>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001ff0:	b510      	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001ff2:	f7ff ffd5 	bl	8001fa0 <port_unlock_from_isr.lto_priv.254>
}
 8001ff6:	bd10      	pop	{r4, pc}
	...

08002000 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8002000:	b500      	push	{lr}
 8002002:	b083      	sub	sp, #12

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 8002004:	4b18      	ldr	r3, [pc, #96]	; (8002068 <chVTDoTickI+0x68>)
 8002006:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002008:	1c5a      	adds	r2, r3, #1
 800200a:	4b17      	ldr	r3, [pc, #92]	; (8002068 <chVTDoTickI+0x68>)
 800200c:	629a      	str	r2, [r3, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800200e:	4b16      	ldr	r3, [pc, #88]	; (8002068 <chVTDoTickI+0x68>)
 8002010:	69da      	ldr	r2, [r3, #28]
 8002012:	4b16      	ldr	r3, [pc, #88]	; (800206c <chVTDoTickI+0x6c>)
 8002014:	429a      	cmp	r2, r3
 8002016:	d024      	beq.n	8002062 <chVTDoTickI+0x62>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 8002018:	4b13      	ldr	r3, [pc, #76]	; (8002068 <chVTDoTickI+0x68>)
 800201a:	69db      	ldr	r3, [r3, #28]
 800201c:	689a      	ldr	r2, [r3, #8]
 800201e:	3a01      	subs	r2, #1
 8002020:	609a      	str	r2, [r3, #8]
 8002022:	e019      	b.n	8002058 <chVTDoTickI+0x58>
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
 8002024:	4b10      	ldr	r3, [pc, #64]	; (8002068 <chVTDoTickI+0x68>)
 8002026:	69db      	ldr	r3, [r3, #28]
 8002028:	9301      	str	r3, [sp, #4]
      fn = vtp->vt_func;
 800202a:	9b01      	ldr	r3, [sp, #4]
 800202c:	68db      	ldr	r3, [r3, #12]
 800202e:	9300      	str	r3, [sp, #0]
      vtp->vt_func = NULL;
 8002030:	9b01      	ldr	r3, [sp, #4]
 8002032:	2200      	movs	r2, #0
 8002034:	60da      	str	r2, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8002036:	9b01      	ldr	r3, [sp, #4]
 8002038:	681b      	ldr	r3, [r3, #0]
 800203a:	4a0c      	ldr	r2, [pc, #48]	; (800206c <chVTDoTickI+0x6c>)
 800203c:	605a      	str	r2, [r3, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800203e:	9b01      	ldr	r3, [sp, #4]
 8002040:	681a      	ldr	r2, [r3, #0]
 8002042:	4b09      	ldr	r3, [pc, #36]	; (8002068 <chVTDoTickI+0x68>)
 8002044:	61da      	str	r2, [r3, #28]
      chSysUnlockFromISR();
 8002046:	f7ff ffd3 	bl	8001ff0 <chSysUnlockFromISR.lto_priv.250>
      fn(vtp->vt_par);
 800204a:	9b01      	ldr	r3, [sp, #4]
 800204c:	691a      	ldr	r2, [r3, #16]
 800204e:	9b00      	ldr	r3, [sp, #0]
 8002050:	0010      	movs	r0, r2
 8002052:	4798      	blx	r3
      chSysLockFromISR();
 8002054:	f7ff ffc4 	bl	8001fe0 <chSysLockFromISR.lto_priv.252>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8002058:	4b03      	ldr	r3, [pc, #12]	; (8002068 <chVTDoTickI+0x68>)
 800205a:	69db      	ldr	r3, [r3, #28]
 800205c:	689b      	ldr	r3, [r3, #8]
 800205e:	2b00      	cmp	r3, #0
 8002060:	d0e0      	beq.n	8002024 <chVTDoTickI+0x24>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002062:	b003      	add	sp, #12
 8002064:	bd00      	pop	{pc}
 8002066:	46c0      	nop			; (mov r8, r8)
 8002068:	20000668 	.word	0x20000668
 800206c:	20000684 	.word	0x20000684

08002070 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8002070:	b082      	sub	sp, #8
 8002072:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8002074:	4b02      	ldr	r3, [pc, #8]	; (8002080 <chRegSetThreadName+0x10>)
 8002076:	699b      	ldr	r3, [r3, #24]
 8002078:	9a01      	ldr	r2, [sp, #4]
 800207a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800207c:	b002      	add	sp, #8
 800207e:	4770      	bx	lr
 8002080:	20000668 	.word	0x20000668
	...

08002090 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8002090:	b082      	sub	sp, #8
 8002092:	9001      	str	r0, [sp, #4]
 8002094:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8002096:	9b01      	ldr	r3, [sp, #4]
 8002098:	9a00      	ldr	r2, [sp, #0]
 800209a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800209c:	b002      	add	sp, #8
 800209e:	4770      	bx	lr

080020a0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80020a0:	b500      	push	{lr}
 80020a2:	b083      	sub	sp, #12
 80020a4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 80020a6:	f7ff ff8b 	bl	8001fc0 <port_wait_for_interrupt>
 80020aa:	e7fc      	b.n	80020a6 <_idle_thread+0x6>
 80020ac:	0000      	movs	r0, r0
	...

080020b0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80020b0:	b500      	push	{lr}
 80020b2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80020b4:	f7ff ff54 	bl	8001f60 <port_init>
  _scheduler_init();
 80020b8:	f000 f942 	bl	8002340 <_scheduler_init>
  _vt_init();
 80020bc:	f000 f840 	bl	8002140 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80020c0:	f7ff fcce 	bl	8001a60 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80020c4:	f7ff fd24 	bl	8001b10 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80020c8:	4b12      	ldr	r3, [pc, #72]	; (8002114 <chSysInit+0x64>)
 80020ca:	2140      	movs	r1, #64	; 0x40
 80020cc:	0018      	movs	r0, r3
 80020ce:	f000 fb4f 	bl	8002770 <_thread_init>
 80020d2:	0002      	movs	r2, r0
 80020d4:	4b10      	ldr	r3, [pc, #64]	; (8002118 <chSysInit+0x68>)
 80020d6:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80020d8:	4b0f      	ldr	r3, [pc, #60]	; (8002118 <chSysInit+0x68>)
 80020da:	699b      	ldr	r3, [r3, #24]
 80020dc:	2201      	movs	r2, #1
 80020de:	771a      	strb	r2, [r3, #28]
#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
#endif

  chSysEnable();
 80020e0:	f7ff ff76 	bl	8001fd0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80020e4:	4b0d      	ldr	r3, [pc, #52]	; (800211c <chSysInit+0x6c>)
 80020e6:	0018      	movs	r0, r3
 80020e8:	f7ff ffc2 	bl	8002070 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80020ec:	4a0c      	ldr	r2, [pc, #48]	; (8002120 <chSysInit+0x70>)
 80020ee:	480d      	ldr	r0, [pc, #52]	; (8002124 <chSysInit+0x74>)
 80020f0:	2300      	movs	r3, #0
 80020f2:	9300      	str	r3, [sp, #0]
 80020f4:	0013      	movs	r3, r2
 80020f6:	2201      	movs	r2, #1
 80020f8:	21d8      	movs	r1, #216	; 0xd8
 80020fa:	f000 fba1 	bl	8002840 <chThdCreateStatic>
 80020fe:	0003      	movs	r3, r0
 8002100:	9303      	str	r3, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 8002102:	4a09      	ldr	r2, [pc, #36]	; (8002128 <chSysInit+0x78>)
 8002104:	9b03      	ldr	r3, [sp, #12]
 8002106:	0011      	movs	r1, r2
 8002108:	0018      	movs	r0, r3
 800210a:	f7ff ffc1 	bl	8002090 <chRegSetThreadNameX>
  }
#endif
}
 800210e:	b005      	add	sp, #20
 8002110:	bd00      	pop	{pc}
 8002112:	46c0      	nop			; (mov r8, r8)
 8002114:	20000698 	.word	0x20000698
 8002118:	20000668 	.word	0x20000668
 800211c:	08002fc0 	.word	0x08002fc0
 8002120:	080020a1 	.word	0x080020a1
 8002124:	200006e0 	.word	0x200006e0
 8002128:	08002f30 	.word	0x08002f30
 800212c:	00000000 	.word	0x00000000

08002130 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002130:	b510      	push	{r4, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8002132:	f7ff ff65 	bl	8002000 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 8002136:	bd10      	pop	{r4, pc}
	...

08002140 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8002140:	4b06      	ldr	r3, [pc, #24]	; (800215c <_vt_init+0x1c>)
 8002142:	4a07      	ldr	r2, [pc, #28]	; (8002160 <_vt_init+0x20>)
 8002144:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8002146:	4b05      	ldr	r3, [pc, #20]	; (800215c <_vt_init+0x1c>)
 8002148:	4a05      	ldr	r2, [pc, #20]	; (8002160 <_vt_init+0x20>)
 800214a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800214c:	4b03      	ldr	r3, [pc, #12]	; (800215c <_vt_init+0x1c>)
 800214e:	2201      	movs	r2, #1
 8002150:	4252      	negs	r2, r2
 8002152:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8002154:	4b01      	ldr	r3, [pc, #4]	; (800215c <_vt_init+0x1c>)
 8002156:	2200      	movs	r2, #0
 8002158:	629a      	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800215a:	4770      	bx	lr
 800215c:	20000668 	.word	0x20000668
 8002160:	20000684 	.word	0x20000684
	...

08002170 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8002170:	b086      	sub	sp, #24
 8002172:	9003      	str	r0, [sp, #12]
 8002174:	9102      	str	r1, [sp, #8]
 8002176:	9201      	str	r2, [sp, #4]
 8002178:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800217a:	9b03      	ldr	r3, [sp, #12]
 800217c:	9a00      	ldr	r2, [sp, #0]
 800217e:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 8002180:	9b03      	ldr	r3, [sp, #12]
 8002182:	9a01      	ldr	r2, [sp, #4]
 8002184:	60da      	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
 8002186:	9b02      	ldr	r3, [sp, #8]
 8002188:	9304      	str	r3, [sp, #16]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 800218a:	4b17      	ldr	r3, [pc, #92]	; (80021e8 <chVTDoSetI+0x78>)
 800218c:	69db      	ldr	r3, [r3, #28]
 800218e:	9305      	str	r3, [sp, #20]
 8002190:	e007      	b.n	80021a2 <chVTDoSetI+0x32>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8002192:	9b05      	ldr	r3, [sp, #20]
 8002194:	689b      	ldr	r3, [r3, #8]
 8002196:	9a04      	ldr	r2, [sp, #16]
 8002198:	1ad3      	subs	r3, r2, r3
 800219a:	9304      	str	r3, [sp, #16]
    p = p->vt_next;
 800219c:	9b05      	ldr	r3, [sp, #20]
 800219e:	681b      	ldr	r3, [r3, #0]
 80021a0:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 80021a2:	9b05      	ldr	r3, [sp, #20]
 80021a4:	689a      	ldr	r2, [r3, #8]
 80021a6:	9b04      	ldr	r3, [sp, #16]
 80021a8:	429a      	cmp	r2, r3
 80021aa:	d3f2      	bcc.n	8002192 <chVTDoSetI+0x22>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80021ac:	9b03      	ldr	r3, [sp, #12]
 80021ae:	9a05      	ldr	r2, [sp, #20]
 80021b0:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80021b2:	9b03      	ldr	r3, [sp, #12]
 80021b4:	681b      	ldr	r3, [r3, #0]
 80021b6:	685a      	ldr	r2, [r3, #4]
 80021b8:	9b03      	ldr	r3, [sp, #12]
 80021ba:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80021bc:	9b03      	ldr	r3, [sp, #12]
 80021be:	685b      	ldr	r3, [r3, #4]
 80021c0:	9a03      	ldr	r2, [sp, #12]
 80021c2:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 80021c4:	9b05      	ldr	r3, [sp, #20]
 80021c6:	9a03      	ldr	r2, [sp, #12]
 80021c8:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 80021ca:	9b03      	ldr	r3, [sp, #12]
 80021cc:	9a04      	ldr	r2, [sp, #16]
 80021ce:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80021d0:	9b05      	ldr	r3, [sp, #20]
 80021d2:	689a      	ldr	r2, [r3, #8]
 80021d4:	9b04      	ldr	r3, [sp, #16]
 80021d6:	1ad2      	subs	r2, r2, r3
 80021d8:	9b05      	ldr	r3, [sp, #20]
 80021da:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80021dc:	4b02      	ldr	r3, [pc, #8]	; (80021e8 <chVTDoSetI+0x78>)
 80021de:	2201      	movs	r2, #1
 80021e0:	4252      	negs	r2, r2
 80021e2:	625a      	str	r2, [r3, #36]	; 0x24
}
 80021e4:	b006      	add	sp, #24
 80021e6:	4770      	bx	lr
 80021e8:	20000668 	.word	0x20000668
 80021ec:	00000000 	.word	0x00000000

080021f0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80021f0:	b082      	sub	sp, #8
 80021f2:	9001      	str	r0, [sp, #4]
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 80021f4:	9b01      	ldr	r3, [sp, #4]
 80021f6:	681b      	ldr	r3, [r3, #0]
 80021f8:	9a01      	ldr	r2, [sp, #4]
 80021fa:	6812      	ldr	r2, [r2, #0]
 80021fc:	6891      	ldr	r1, [r2, #8]
 80021fe:	9a01      	ldr	r2, [sp, #4]
 8002200:	6892      	ldr	r2, [r2, #8]
 8002202:	188a      	adds	r2, r1, r2
 8002204:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 8002206:	9b01      	ldr	r3, [sp, #4]
 8002208:	685b      	ldr	r3, [r3, #4]
 800220a:	9a01      	ldr	r2, [sp, #4]
 800220c:	6812      	ldr	r2, [r2, #0]
 800220e:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8002210:	9b01      	ldr	r3, [sp, #4]
 8002212:	681b      	ldr	r3, [r3, #0]
 8002214:	9a01      	ldr	r2, [sp, #4]
 8002216:	6852      	ldr	r2, [r2, #4]
 8002218:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 800221a:	9b01      	ldr	r3, [sp, #4]
 800221c:	2200      	movs	r2, #0
 800221e:	60da      	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8002220:	4b02      	ldr	r3, [pc, #8]	; (800222c <chVTDoResetI+0x3c>)
 8002222:	2201      	movs	r2, #1
 8002224:	4252      	negs	r2, r2
 8002226:	625a      	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002228:	b002      	add	sp, #8
 800222a:	4770      	bx	lr
 800222c:	20000668 	.word	0x20000668

08002230 <port_lock.lto_priv.248>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002230:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8002232:	4770      	bx	lr
	...

08002240 <port_unlock.lto_priv.245>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002240:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8002242:	4770      	bx	lr
	...

08002250 <port_lock_from_isr.lto_priv.257>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002250:	b510      	push	{r4, lr}

  port_lock();
 8002252:	f7ff ffed 	bl	8002230 <port_lock.lto_priv.248>
}
 8002256:	bd10      	pop	{r4, pc}
	...

08002260 <port_unlock_from_isr.lto_priv.255>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002260:	b510      	push	{r4, lr}

  port_unlock();
 8002262:	f7ff ffed 	bl	8002240 <port_unlock.lto_priv.245>
}
 8002266:	bd10      	pop	{r4, pc}
	...

08002270 <queue_init.lto_priv.242>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002270:	b082      	sub	sp, #8
 8002272:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002274:	9b01      	ldr	r3, [sp, #4]
 8002276:	9a01      	ldr	r2, [sp, #4]
 8002278:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800227a:	9b01      	ldr	r3, [sp, #4]
 800227c:	9a01      	ldr	r2, [sp, #4]
 800227e:	605a      	str	r2, [r3, #4]
}
 8002280:	b002      	add	sp, #8
 8002282:	4770      	bx	lr
	...

08002290 <queue_fifo_remove.lto_priv.240>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002290:	b084      	sub	sp, #16
 8002292:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8002294:	9b01      	ldr	r3, [sp, #4]
 8002296:	681b      	ldr	r3, [r3, #0]
 8002298:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800229a:	9b03      	ldr	r3, [sp, #12]
 800229c:	681a      	ldr	r2, [r3, #0]
 800229e:	9b01      	ldr	r3, [sp, #4]
 80022a0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80022a2:	9b01      	ldr	r3, [sp, #4]
 80022a4:	681b      	ldr	r3, [r3, #0]
 80022a6:	9a01      	ldr	r2, [sp, #4]
 80022a8:	605a      	str	r2, [r3, #4]

  return tp;
 80022aa:	9b03      	ldr	r3, [sp, #12]
}
 80022ac:	0018      	movs	r0, r3
 80022ae:	b004      	add	sp, #16
 80022b0:	4770      	bx	lr
 80022b2:	46c0      	nop			; (mov r8, r8)
	...

080022c0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 80022c0:	b082      	sub	sp, #8
 80022c2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 80022c4:	9b01      	ldr	r3, [sp, #4]
 80022c6:	685b      	ldr	r3, [r3, #4]
 80022c8:	9a01      	ldr	r2, [sp, #4]
 80022ca:	6812      	ldr	r2, [r2, #0]
 80022cc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80022ce:	9b01      	ldr	r3, [sp, #4]
 80022d0:	681b      	ldr	r3, [r3, #0]
 80022d2:	9a01      	ldr	r2, [sp, #4]
 80022d4:	6852      	ldr	r2, [r2, #4]
 80022d6:	605a      	str	r2, [r3, #4]

  return tp;
 80022d8:	9b01      	ldr	r3, [sp, #4]
}
 80022da:	0018      	movs	r0, r3
 80022dc:	b002      	add	sp, #8
 80022de:	4770      	bx	lr

080022e0 <chSysLockFromISR.lto_priv.253>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80022e0:	b510      	push	{r4, lr}

  port_lock_from_isr();
 80022e2:	f7ff ffb5 	bl	8002250 <port_lock_from_isr.lto_priv.257>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80022e6:	bd10      	pop	{r4, pc}
	...

080022f0 <chSysUnlockFromISR.lto_priv.251>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80022f0:	b510      	push	{r4, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80022f2:	f7ff ffb5 	bl	8002260 <port_unlock_from_isr.lto_priv.255>
}
 80022f6:	bd10      	pop	{r4, pc}
	...

08002300 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8002300:	b082      	sub	sp, #8
 8002302:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8002304:	9b01      	ldr	r3, [sp, #4]
 8002306:	68db      	ldr	r3, [r3, #12]
 8002308:	1e5a      	subs	r2, r3, #1
 800230a:	4193      	sbcs	r3, r2
 800230c:	b2db      	uxtb	r3, r3
}
 800230e:	0018      	movs	r0, r3
 8002310:	b002      	add	sp, #8
 8002312:	4770      	bx	lr
	...

08002320 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8002320:	b082      	sub	sp, #8
 8002322:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8002324:	9b01      	ldr	r3, [sp, #4]
 8002326:	689b      	ldr	r3, [r3, #8]
 8002328:	1c5a      	adds	r2, r3, #1
 800232a:	9b01      	ldr	r3, [sp, #4]
 800232c:	609a      	str	r2, [r3, #8]
}
 800232e:	b002      	add	sp, #8
 8002330:	4770      	bx	lr
 8002332:	46c0      	nop			; (mov r8, r8)
	...

08002340 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8002340:	b510      	push	{r4, lr}

  queue_init(&ch.rlist.r_queue);
 8002342:	4b07      	ldr	r3, [pc, #28]	; (8002360 <_scheduler_init+0x20>)
 8002344:	0018      	movs	r0, r3
 8002346:	f7ff ff93 	bl	8002270 <queue_init.lto_priv.242>
  ch.rlist.r_prio = NOPRIO;
 800234a:	4b05      	ldr	r3, [pc, #20]	; (8002360 <_scheduler_init+0x20>)
 800234c:	2200      	movs	r2, #0
 800234e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8002350:	4b03      	ldr	r3, [pc, #12]	; (8002360 <_scheduler_init+0x20>)
 8002352:	4a03      	ldr	r2, [pc, #12]	; (8002360 <_scheduler_init+0x20>)
 8002354:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8002356:	4b02      	ldr	r3, [pc, #8]	; (8002360 <_scheduler_init+0x20>)
 8002358:	4a01      	ldr	r2, [pc, #4]	; (8002360 <_scheduler_init+0x20>)
 800235a:	615a      	str	r2, [r3, #20]
#endif
}
 800235c:	bd10      	pop	{r4, pc}
 800235e:	46c0      	nop			; (mov r8, r8)
 8002360:	20000668 	.word	0x20000668
	...

08002370 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8002370:	b084      	sub	sp, #16
 8002372:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8002374:	9b01      	ldr	r3, [sp, #4]
 8002376:	2200      	movs	r2, #0
 8002378:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 800237a:	4b0e      	ldr	r3, [pc, #56]	; (80023b4 <chSchReadyI+0x44>)
 800237c:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800237e:	9b03      	ldr	r3, [sp, #12]
 8002380:	681b      	ldr	r3, [r3, #0]
 8002382:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8002384:	9b03      	ldr	r3, [sp, #12]
 8002386:	689a      	ldr	r2, [r3, #8]
 8002388:	9b01      	ldr	r3, [sp, #4]
 800238a:	689b      	ldr	r3, [r3, #8]
 800238c:	429a      	cmp	r2, r3
 800238e:	d2f6      	bcs.n	800237e <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8002390:	9b01      	ldr	r3, [sp, #4]
 8002392:	9a03      	ldr	r2, [sp, #12]
 8002394:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8002396:	9b03      	ldr	r3, [sp, #12]
 8002398:	685a      	ldr	r2, [r3, #4]
 800239a:	9b01      	ldr	r3, [sp, #4]
 800239c:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800239e:	9b01      	ldr	r3, [sp, #4]
 80023a0:	685b      	ldr	r3, [r3, #4]
 80023a2:	9a01      	ldr	r2, [sp, #4]
 80023a4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80023a6:	9b03      	ldr	r3, [sp, #12]
 80023a8:	9a01      	ldr	r2, [sp, #4]
 80023aa:	605a      	str	r2, [r3, #4]

  return tp;
 80023ac:	9b01      	ldr	r3, [sp, #4]
}
 80023ae:	0018      	movs	r0, r3
 80023b0:	b004      	add	sp, #16
 80023b2:	4770      	bx	lr
 80023b4:	20000668 	.word	0x20000668
	...

080023c0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80023c0:	b500      	push	{lr}
 80023c2:	b085      	sub	sp, #20
 80023c4:	0002      	movs	r2, r0
 80023c6:	466b      	mov	r3, sp
 80023c8:	3307      	adds	r3, #7
 80023ca:	701a      	strb	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80023cc:	4b0d      	ldr	r3, [pc, #52]	; (8002404 <chSchGoSleepS+0x44>)
 80023ce:	699b      	ldr	r3, [r3, #24]
 80023d0:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 80023d2:	9b03      	ldr	r3, [sp, #12]
 80023d4:	466a      	mov	r2, sp
 80023d6:	3207      	adds	r2, #7
 80023d8:	7812      	ldrb	r2, [r2, #0]
 80023da:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80023dc:	4b09      	ldr	r3, [pc, #36]	; (8002404 <chSchGoSleepS+0x44>)
 80023de:	0018      	movs	r0, r3
 80023e0:	f7ff ff56 	bl	8002290 <queue_fifo_remove.lto_priv.240>
 80023e4:	0002      	movs	r2, r0
 80023e6:	4b07      	ldr	r3, [pc, #28]	; (8002404 <chSchGoSleepS+0x44>)
 80023e8:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80023ea:	4b06      	ldr	r3, [pc, #24]	; (8002404 <chSchGoSleepS+0x44>)
 80023ec:	699b      	ldr	r3, [r3, #24]
 80023ee:	2201      	movs	r2, #1
 80023f0:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 80023f2:	4b04      	ldr	r3, [pc, #16]	; (8002404 <chSchGoSleepS+0x44>)
 80023f4:	699b      	ldr	r3, [r3, #24]
 80023f6:	9a03      	ldr	r2, [sp, #12]
 80023f8:	0011      	movs	r1, r2
 80023fa:	0018      	movs	r0, r3
 80023fc:	f7fd fec8 	bl	8000190 <_port_switch>
}
 8002400:	b005      	add	sp, #20
 8002402:	bd00      	pop	{pc}
 8002404:	20000668 	.word	0x20000668
	...

08002410 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8002410:	b500      	push	{lr}
 8002412:	b085      	sub	sp, #20
 8002414:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8002416:	9b01      	ldr	r3, [sp, #4]
 8002418:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 800241a:	f7ff ff61 	bl	80022e0 <chSysLockFromISR.lto_priv.253>
  switch (tp->p_state) {
 800241e:	9b03      	ldr	r3, [sp, #12]
 8002420:	7f1b      	ldrb	r3, [r3, #28]
 8002422:	2b07      	cmp	r3, #7
 8002424:	d815      	bhi.n	8002452 <wakeup+0x42>
 8002426:	009a      	lsls	r2, r3, #2
 8002428:	4b10      	ldr	r3, [pc, #64]	; (800246c <wakeup+0x5c>)
 800242a:	18d3      	adds	r3, r2, r3
 800242c:	681b      	ldr	r3, [r3, #0]
 800242e:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8002430:	f7ff ff5e 	bl	80022f0 <chSysUnlockFromISR.lto_priv.251>
 8002434:	e017      	b.n	8002466 <wakeup+0x56>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8002436:	9b03      	ldr	r3, [sp, #12]
 8002438:	6a1b      	ldr	r3, [r3, #32]
 800243a:	2200      	movs	r2, #0
 800243c:	601a      	str	r2, [r3, #0]
 800243e:	e008      	b.n	8002452 <wakeup+0x42>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8002440:	9b03      	ldr	r3, [sp, #12]
 8002442:	6a1b      	ldr	r3, [r3, #32]
 8002444:	0018      	movs	r0, r3
 8002446:	f7ff ff6b 	bl	8002320 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800244a:	9b03      	ldr	r3, [sp, #12]
 800244c:	0018      	movs	r0, r3
 800244e:	f7ff ff37 	bl	80022c0 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8002452:	9b03      	ldr	r3, [sp, #12]
 8002454:	2201      	movs	r2, #1
 8002456:	4252      	negs	r2, r2
 8002458:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 800245a:	9b03      	ldr	r3, [sp, #12]
 800245c:	0018      	movs	r0, r3
 800245e:	f7ff ff87 	bl	8002370 <chSchReadyI>
  chSysUnlockFromISR();
 8002462:	f7ff ff45 	bl	80022f0 <chSysUnlockFromISR.lto_priv.251>
}
 8002466:	b005      	add	sp, #20
 8002468:	bd00      	pop	{pc}
 800246a:	46c0      	nop			; (mov r8, r8)
 800246c:	08003070 	.word	0x08003070

08002470 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8002470:	b500      	push	{lr}
 8002472:	b089      	sub	sp, #36	; 0x24
 8002474:	0002      	movs	r2, r0
 8002476:	9100      	str	r1, [sp, #0]
 8002478:	466b      	mov	r3, sp
 800247a:	3307      	adds	r3, #7
 800247c:	701a      	strb	r2, [r3, #0]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800247e:	9b00      	ldr	r3, [sp, #0]
 8002480:	3301      	adds	r3, #1
 8002482:	d017      	beq.n	80024b4 <chSchGoSleepTimeoutS+0x44>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8002484:	4b11      	ldr	r3, [pc, #68]	; (80024cc <chSchGoSleepTimeoutS+0x5c>)
 8002486:	699b      	ldr	r3, [r3, #24]
 8002488:	4a11      	ldr	r2, [pc, #68]	; (80024d0 <chSchGoSleepTimeoutS+0x60>)
 800248a:	9900      	ldr	r1, [sp, #0]
 800248c:	a803      	add	r0, sp, #12
 800248e:	f7ff fe6f 	bl	8002170 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8002492:	466b      	mov	r3, sp
 8002494:	3307      	adds	r3, #7
 8002496:	781b      	ldrb	r3, [r3, #0]
 8002498:	0018      	movs	r0, r3
 800249a:	f7ff ff91 	bl	80023c0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800249e:	ab03      	add	r3, sp, #12
 80024a0:	0018      	movs	r0, r3
 80024a2:	f7ff ff2d 	bl	8002300 <chVTIsArmedI>
 80024a6:	1e03      	subs	r3, r0, #0
 80024a8:	d00a      	beq.n	80024c0 <chSchGoSleepTimeoutS+0x50>
      chVTDoResetI(&vt);
 80024aa:	ab03      	add	r3, sp, #12
 80024ac:	0018      	movs	r0, r3
 80024ae:	f7ff fe9f 	bl	80021f0 <chVTDoResetI>
 80024b2:	e005      	b.n	80024c0 <chSchGoSleepTimeoutS+0x50>
    }
  }
  else {
    chSchGoSleepS(newstate);
 80024b4:	466b      	mov	r3, sp
 80024b6:	3307      	adds	r3, #7
 80024b8:	781b      	ldrb	r3, [r3, #0]
 80024ba:	0018      	movs	r0, r3
 80024bc:	f7ff ff80 	bl	80023c0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 80024c0:	4b02      	ldr	r3, [pc, #8]	; (80024cc <chSchGoSleepTimeoutS+0x5c>)
 80024c2:	699b      	ldr	r3, [r3, #24]
 80024c4:	6a1b      	ldr	r3, [r3, #32]
}
 80024c6:	0018      	movs	r0, r3
 80024c8:	b009      	add	sp, #36	; 0x24
 80024ca:	bd00      	pop	{pc}
 80024cc:	20000668 	.word	0x20000668
 80024d0:	08002411 	.word	0x08002411
	...

080024e0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80024e0:	b500      	push	{lr}
 80024e2:	b085      	sub	sp, #20
 80024e4:	9001      	str	r0, [sp, #4]
 80024e6:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80024e8:	9b01      	ldr	r3, [sp, #4]
 80024ea:	9a00      	ldr	r2, [sp, #0]
 80024ec:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80024ee:	9b01      	ldr	r3, [sp, #4]
 80024f0:	689a      	ldr	r2, [r3, #8]
 80024f2:	4b0f      	ldr	r3, [pc, #60]	; (8002530 <chSchWakeupS+0x50>)
 80024f4:	699b      	ldr	r3, [r3, #24]
 80024f6:	689b      	ldr	r3, [r3, #8]
 80024f8:	429a      	cmp	r2, r3
 80024fa:	d804      	bhi.n	8002506 <chSchWakeupS+0x26>
    (void) chSchReadyI(ntp);
 80024fc:	9b01      	ldr	r3, [sp, #4]
 80024fe:	0018      	movs	r0, r3
 8002500:	f7ff ff36 	bl	8002370 <chSchReadyI>
 8002504:	e012      	b.n	800252c <chSchWakeupS+0x4c>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8002506:	4b0a      	ldr	r3, [pc, #40]	; (8002530 <chSchWakeupS+0x50>)
 8002508:	699b      	ldr	r3, [r3, #24]
 800250a:	0018      	movs	r0, r3
 800250c:	f7ff ff30 	bl	8002370 <chSchReadyI>
 8002510:	0003      	movs	r3, r0
 8002512:	9303      	str	r3, [sp, #12]
    setcurrp(ntp);
 8002514:	4b06      	ldr	r3, [pc, #24]	; (8002530 <chSchWakeupS+0x50>)
 8002516:	9a01      	ldr	r2, [sp, #4]
 8002518:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800251a:	9b01      	ldr	r3, [sp, #4]
 800251c:	2201      	movs	r2, #1
 800251e:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8002520:	9a03      	ldr	r2, [sp, #12]
 8002522:	9b01      	ldr	r3, [sp, #4]
 8002524:	0011      	movs	r1, r2
 8002526:	0018      	movs	r0, r3
 8002528:	f7fd fe32 	bl	8000190 <_port_switch>
  }
}
 800252c:	b005      	add	sp, #20
 800252e:	bd00      	pop	{pc}
 8002530:	20000668 	.word	0x20000668
	...

08002540 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8002540:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8002542:	4b08      	ldr	r3, [pc, #32]	; (8002564 <chSchIsPreemptionRequired+0x24>)
 8002544:	681b      	ldr	r3, [r3, #0]
 8002546:	689b      	ldr	r3, [r3, #8]
 8002548:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 800254a:	4b06      	ldr	r3, [pc, #24]	; (8002564 <chSchIsPreemptionRequired+0x24>)
 800254c:	699b      	ldr	r3, [r3, #24]
 800254e:	689b      	ldr	r3, [r3, #8]
 8002550:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8002552:	9b01      	ldr	r3, [sp, #4]
 8002554:	9a00      	ldr	r2, [sp, #0]
 8002556:	429a      	cmp	r2, r3
 8002558:	419b      	sbcs	r3, r3
 800255a:	425b      	negs	r3, r3
 800255c:	b2db      	uxtb	r3, r3
#endif
}
 800255e:	0018      	movs	r0, r3
 8002560:	b002      	add	sp, #8
 8002562:	4770      	bx	lr
 8002564:	20000668 	.word	0x20000668
	...

08002570 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8002570:	b500      	push	{lr}
 8002572:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8002574:	4b19      	ldr	r3, [pc, #100]	; (80025dc <chSchDoRescheduleAhead+0x6c>)
 8002576:	699b      	ldr	r3, [r3, #24]
 8002578:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800257a:	4b18      	ldr	r3, [pc, #96]	; (80025dc <chSchDoRescheduleAhead+0x6c>)
 800257c:	0018      	movs	r0, r3
 800257e:	f7ff fe87 	bl	8002290 <queue_fifo_remove.lto_priv.240>
 8002582:	0002      	movs	r2, r0
 8002584:	4b15      	ldr	r3, [pc, #84]	; (80025dc <chSchDoRescheduleAhead+0x6c>)
 8002586:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8002588:	4b14      	ldr	r3, [pc, #80]	; (80025dc <chSchDoRescheduleAhead+0x6c>)
 800258a:	699b      	ldr	r3, [r3, #24]
 800258c:	2201      	movs	r2, #1
 800258e:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8002590:	9b00      	ldr	r3, [sp, #0]
 8002592:	2200      	movs	r2, #0
 8002594:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8002596:	4b11      	ldr	r3, [pc, #68]	; (80025dc <chSchDoRescheduleAhead+0x6c>)
 8002598:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 800259a:	9b01      	ldr	r3, [sp, #4]
 800259c:	681b      	ldr	r3, [r3, #0]
 800259e:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 80025a0:	9b01      	ldr	r3, [sp, #4]
 80025a2:	689a      	ldr	r2, [r3, #8]
 80025a4:	9b00      	ldr	r3, [sp, #0]
 80025a6:	689b      	ldr	r3, [r3, #8]
 80025a8:	429a      	cmp	r2, r3
 80025aa:	d8f6      	bhi.n	800259a <chSchDoRescheduleAhead+0x2a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80025ac:	9b00      	ldr	r3, [sp, #0]
 80025ae:	9a01      	ldr	r2, [sp, #4]
 80025b0:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 80025b2:	9b01      	ldr	r3, [sp, #4]
 80025b4:	685a      	ldr	r2, [r3, #4]
 80025b6:	9b00      	ldr	r3, [sp, #0]
 80025b8:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 80025ba:	9b00      	ldr	r3, [sp, #0]
 80025bc:	685b      	ldr	r3, [r3, #4]
 80025be:	9a00      	ldr	r2, [sp, #0]
 80025c0:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 80025c2:	9b01      	ldr	r3, [sp, #4]
 80025c4:	9a00      	ldr	r2, [sp, #0]
 80025c6:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 80025c8:	4b04      	ldr	r3, [pc, #16]	; (80025dc <chSchDoRescheduleAhead+0x6c>)
 80025ca:	699b      	ldr	r3, [r3, #24]
 80025cc:	9a00      	ldr	r2, [sp, #0]
 80025ce:	0011      	movs	r1, r2
 80025d0:	0018      	movs	r0, r3
 80025d2:	f7fd fddd 	bl	8000190 <_port_switch>
}
 80025d6:	b003      	add	sp, #12
 80025d8:	bd00      	pop	{pc}
 80025da:	46c0      	nop			; (mov r8, r8)
 80025dc:	20000668 	.word	0x20000668

080025e0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80025e0:	b510      	push	{r4, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 80025e2:	f7ff ffc5 	bl	8002570 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 80025e6:	bd10      	pop	{r4, pc}
	...

080025f0 <port_lock.lto_priv.249>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80025f0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80025f2:	4770      	bx	lr
	...

08002600 <port_unlock.lto_priv.246>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002600:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8002602:	4770      	bx	lr
	...

08002610 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8002610:	b082      	sub	sp, #8
 8002612:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8002614:	9b01      	ldr	r3, [sp, #4]
 8002616:	9a01      	ldr	r2, [sp, #4]
 8002618:	601a      	str	r2, [r3, #0]
}
 800261a:	b002      	add	sp, #8
 800261c:	4770      	bx	lr
 800261e:	46c0      	nop			; (mov r8, r8)

08002620 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8002620:	b082      	sub	sp, #8
 8002622:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8002624:	9b01      	ldr	r3, [sp, #4]
 8002626:	681a      	ldr	r2, [r3, #0]
 8002628:	9b01      	ldr	r3, [sp, #4]
 800262a:	1ad3      	subs	r3, r2, r3
 800262c:	1e5a      	subs	r2, r3, #1
 800262e:	4193      	sbcs	r3, r2
 8002630:	b2db      	uxtb	r3, r3
}
 8002632:	0018      	movs	r0, r3
 8002634:	b002      	add	sp, #8
 8002636:	4770      	bx	lr
	...

08002640 <queue_init.lto_priv.243>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002640:	b082      	sub	sp, #8
 8002642:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002644:	9b01      	ldr	r3, [sp, #4]
 8002646:	9a01      	ldr	r2, [sp, #4]
 8002648:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800264a:	9b01      	ldr	r3, [sp, #4]
 800264c:	9a01      	ldr	r2, [sp, #4]
 800264e:	605a      	str	r2, [r3, #4]
}
 8002650:	b002      	add	sp, #8
 8002652:	4770      	bx	lr
	...

08002660 <queue_notempty.lto_priv.231>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002660:	b082      	sub	sp, #8
 8002662:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002664:	9b01      	ldr	r3, [sp, #4]
 8002666:	681a      	ldr	r2, [r3, #0]
 8002668:	9b01      	ldr	r3, [sp, #4]
 800266a:	1ad3      	subs	r3, r2, r3
 800266c:	1e5a      	subs	r2, r3, #1
 800266e:	4193      	sbcs	r3, r2
 8002670:	b2db      	uxtb	r3, r3
}
 8002672:	0018      	movs	r0, r3
 8002674:	b002      	add	sp, #8
 8002676:	4770      	bx	lr
	...

08002680 <list_remove>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
 8002680:	b084      	sub	sp, #16
 8002682:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8002684:	9b01      	ldr	r3, [sp, #4]
 8002686:	681b      	ldr	r3, [r3, #0]
 8002688:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 800268a:	9b03      	ldr	r3, [sp, #12]
 800268c:	681a      	ldr	r2, [r3, #0]
 800268e:	9b01      	ldr	r3, [sp, #4]
 8002690:	601a      	str	r2, [r3, #0]

  return tp;
 8002692:	9b03      	ldr	r3, [sp, #12]
}
 8002694:	0018      	movs	r0, r3
 8002696:	b004      	add	sp, #16
 8002698:	4770      	bx	lr
 800269a:	46c0      	nop			; (mov r8, r8)
 800269c:	0000      	movs	r0, r0
	...

080026a0 <queue_insert.lto_priv.237>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 80026a0:	b082      	sub	sp, #8
 80026a2:	9001      	str	r0, [sp, #4]
 80026a4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 80026a6:	9b01      	ldr	r3, [sp, #4]
 80026a8:	9a00      	ldr	r2, [sp, #0]
 80026aa:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80026ac:	9b00      	ldr	r3, [sp, #0]
 80026ae:	685a      	ldr	r2, [r3, #4]
 80026b0:	9b01      	ldr	r3, [sp, #4]
 80026b2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80026b4:	9b01      	ldr	r3, [sp, #4]
 80026b6:	685b      	ldr	r3, [r3, #4]
 80026b8:	9a01      	ldr	r2, [sp, #4]
 80026ba:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 80026bc:	9b00      	ldr	r3, [sp, #0]
 80026be:	9a01      	ldr	r2, [sp, #4]
 80026c0:	605a      	str	r2, [r3, #4]
}
 80026c2:	b002      	add	sp, #8
 80026c4:	4770      	bx	lr
 80026c6:	46c0      	nop			; (mov r8, r8)
	...

080026d0 <queue_fifo_remove.lto_priv.241>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80026d0:	b084      	sub	sp, #16
 80026d2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80026d4:	9b01      	ldr	r3, [sp, #4]
 80026d6:	681b      	ldr	r3, [r3, #0]
 80026d8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 80026da:	9b03      	ldr	r3, [sp, #12]
 80026dc:	681a      	ldr	r2, [r3, #0]
 80026de:	9b01      	ldr	r3, [sp, #4]
 80026e0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80026e2:	9b01      	ldr	r3, [sp, #4]
 80026e4:	681b      	ldr	r3, [r3, #0]
 80026e6:	9a01      	ldr	r2, [sp, #4]
 80026e8:	605a      	str	r2, [r3, #4]

  return tp;
 80026ea:	9b03      	ldr	r3, [sp, #12]
}
 80026ec:	0018      	movs	r0, r3
 80026ee:	b004      	add	sp, #16
 80026f0:	4770      	bx	lr
 80026f2:	46c0      	nop			; (mov r8, r8)
	...

08002700 <chSysLock.lto_priv.217>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002700:	b510      	push	{r4, lr}

  port_lock();
 8002702:	f7ff ff75 	bl	80025f0 <port_lock.lto_priv.249>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002706:	bd10      	pop	{r4, pc}
	...

08002710 <chSysUnlock.lto_priv.210>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002710:	b510      	push	{r4, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002712:	f7ff ff75 	bl	8002600 <port_unlock.lto_priv.246>
}
 8002716:	bd10      	pop	{r4, pc}
	...

08002720 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 8002720:	b500      	push	{lr}
 8002722:	b083      	sub	sp, #12
 8002724:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8002726:	9b01      	ldr	r3, [sp, #4]
 8002728:	0019      	movs	r1, r3
 800272a:	2008      	movs	r0, #8
 800272c:	f7ff fea0 	bl	8002470 <chSchGoSleepTimeoutS>
}
 8002730:	b003      	add	sp, #12
 8002732:	bd00      	pop	{pc}
	...

08002740 <chThdDoDequeueNextI.lto_priv.239>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002740:	b500      	push	{lr}
 8002742:	b085      	sub	sp, #20
 8002744:	9001      	str	r0, [sp, #4]
 8002746:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 8002748:	9b01      	ldr	r3, [sp, #4]
 800274a:	0018      	movs	r0, r3
 800274c:	f7ff ffc0 	bl	80026d0 <queue_fifo_remove.lto_priv.241>
 8002750:	0003      	movs	r3, r0
 8002752:	9303      	str	r3, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8002754:	9b03      	ldr	r3, [sp, #12]
 8002756:	9a00      	ldr	r2, [sp, #0]
 8002758:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 800275a:	9b03      	ldr	r3, [sp, #12]
 800275c:	0018      	movs	r0, r3
 800275e:	f7ff fe07 	bl	8002370 <chSchReadyI>
}
 8002762:	b005      	add	sp, #20
 8002764:	bd00      	pop	{pc}
 8002766:	46c0      	nop			; (mov r8, r8)
	...

08002770 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8002770:	b500      	push	{lr}
 8002772:	b083      	sub	sp, #12
 8002774:	9001      	str	r0, [sp, #4]
 8002776:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8002778:	9b01      	ldr	r3, [sp, #4]
 800277a:	9a00      	ldr	r2, [sp, #0]
 800277c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 800277e:	9b01      	ldr	r3, [sp, #4]
 8002780:	2202      	movs	r2, #2
 8002782:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002784:	9b01      	ldr	r3, [sp, #4]
 8002786:	2200      	movs	r2, #0
 8002788:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800278a:	9b01      	ldr	r3, [sp, #4]
 800278c:	9a00      	ldr	r2, [sp, #0]
 800278e:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8002790:	9b01      	ldr	r3, [sp, #4]
 8002792:	2200      	movs	r2, #0
 8002794:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002796:	9b01      	ldr	r3, [sp, #4]
 8002798:	2200      	movs	r2, #0
 800279a:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800279c:	9b01      	ldr	r3, [sp, #4]
 800279e:	2201      	movs	r2, #1
 80027a0:	779a      	strb	r2, [r3, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80027a2:	9b01      	ldr	r3, [sp, #4]
 80027a4:	2200      	movs	r2, #0
 80027a6:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 80027a8:	9b01      	ldr	r3, [sp, #4]
 80027aa:	4a0d      	ldr	r2, [pc, #52]	; (80027e0 <_thread_init+0x70>)
 80027ac:	611a      	str	r2, [r3, #16]
 80027ae:	4b0c      	ldr	r3, [pc, #48]	; (80027e0 <_thread_init+0x70>)
 80027b0:	695a      	ldr	r2, [r3, #20]
 80027b2:	9b01      	ldr	r3, [sp, #4]
 80027b4:	615a      	str	r2, [r3, #20]
 80027b6:	9b01      	ldr	r3, [sp, #4]
 80027b8:	695b      	ldr	r3, [r3, #20]
 80027ba:	9a01      	ldr	r2, [sp, #4]
 80027bc:	611a      	str	r2, [r3, #16]
 80027be:	4b08      	ldr	r3, [pc, #32]	; (80027e0 <_thread_init+0x70>)
 80027c0:	9a01      	ldr	r2, [sp, #4]
 80027c2:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80027c4:	9b01      	ldr	r3, [sp, #4]
 80027c6:	3324      	adds	r3, #36	; 0x24
 80027c8:	0018      	movs	r0, r3
 80027ca:	f7ff ff21 	bl	8002610 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80027ce:	9b01      	ldr	r3, [sp, #4]
 80027d0:	3328      	adds	r3, #40	; 0x28
 80027d2:	0018      	movs	r0, r3
 80027d4:	f7ff ff34 	bl	8002640 <queue_init.lto_priv.243>
  chTMObjectInit(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 80027d8:	9b01      	ldr	r3, [sp, #4]
}
 80027da:	0018      	movs	r0, r3
 80027dc:	b003      	add	sp, #12
 80027de:	bd00      	pop	{pc}
 80027e0:	20000668 	.word	0x20000668
	...

080027f0 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 80027f0:	b500      	push	{lr}
 80027f2:	b087      	sub	sp, #28
 80027f4:	9003      	str	r0, [sp, #12]
 80027f6:	9102      	str	r1, [sp, #8]
 80027f8:	9201      	str	r2, [sp, #4]
 80027fa:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 80027fc:	9b03      	ldr	r3, [sp, #12]
 80027fe:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002800:	9b02      	ldr	r3, [sp, #8]
 8002802:	3b24      	subs	r3, #36	; 0x24
 8002804:	9a03      	ldr	r2, [sp, #12]
 8002806:	18d2      	adds	r2, r2, r3
 8002808:	9b05      	ldr	r3, [sp, #20]
 800280a:	60da      	str	r2, [r3, #12]
 800280c:	9b05      	ldr	r3, [sp, #20]
 800280e:	68db      	ldr	r3, [r3, #12]
 8002810:	9a00      	ldr	r2, [sp, #0]
 8002812:	611a      	str	r2, [r3, #16]
 8002814:	9b05      	ldr	r3, [sp, #20]
 8002816:	68db      	ldr	r3, [r3, #12]
 8002818:	9a08      	ldr	r2, [sp, #32]
 800281a:	615a      	str	r2, [r3, #20]
 800281c:	9b05      	ldr	r3, [sp, #20]
 800281e:	68db      	ldr	r3, [r3, #12]
 8002820:	4a05      	ldr	r2, [pc, #20]	; (8002838 <chThdCreateI+0x48>)
 8002822:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 8002824:	9a01      	ldr	r2, [sp, #4]
 8002826:	9b05      	ldr	r3, [sp, #20]
 8002828:	0011      	movs	r1, r2
 800282a:	0018      	movs	r0, r3
 800282c:	f7ff ffa0 	bl	8002770 <_thread_init>
 8002830:	0003      	movs	r3, r0
}
 8002832:	0018      	movs	r0, r3
 8002834:	b007      	add	sp, #28
 8002836:	bd00      	pop	{pc}
 8002838:	080001b1 	.word	0x080001b1
 800283c:	00000000 	.word	0x00000000

08002840 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8002840:	b510      	push	{r4, lr}
 8002842:	b088      	sub	sp, #32
 8002844:	9005      	str	r0, [sp, #20]
 8002846:	9104      	str	r1, [sp, #16]
 8002848:	9203      	str	r2, [sp, #12]
 800284a:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800284c:	f7ff ff58 	bl	8002700 <chSysLock.lto_priv.217>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8002850:	9c02      	ldr	r4, [sp, #8]
 8002852:	9a03      	ldr	r2, [sp, #12]
 8002854:	9904      	ldr	r1, [sp, #16]
 8002856:	9805      	ldr	r0, [sp, #20]
 8002858:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800285a:	9300      	str	r3, [sp, #0]
 800285c:	0023      	movs	r3, r4
 800285e:	f7ff ffc7 	bl	80027f0 <chThdCreateI>
 8002862:	0003      	movs	r3, r0
 8002864:	9307      	str	r3, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8002866:	9b07      	ldr	r3, [sp, #28]
 8002868:	2100      	movs	r1, #0
 800286a:	0018      	movs	r0, r3
 800286c:	f7ff fe38 	bl	80024e0 <chSchWakeupS>
  chSysUnlock();
 8002870:	f7ff ff4e 	bl	8002710 <chSysUnlock.lto_priv.210>

  return tp;
 8002874:	9b07      	ldr	r3, [sp, #28]
}
 8002876:	0018      	movs	r0, r3
 8002878:	b008      	add	sp, #32
 800287a:	bd10      	pop	{r4, pc}
 800287c:	0000      	movs	r0, r0
	...

08002880 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8002880:	b500      	push	{lr}
 8002882:	b083      	sub	sp, #12
 8002884:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002886:	f7ff ff3b 	bl	8002700 <chSysLock.lto_priv.217>
  chThdSleepS(time);
 800288a:	9b01      	ldr	r3, [sp, #4]
 800288c:	0018      	movs	r0, r3
 800288e:	f7ff ff47 	bl	8002720 <chThdSleepS>
  chSysUnlock();
 8002892:	f7ff ff3d 	bl	8002710 <chSysUnlock.lto_priv.210>
}
 8002896:	b003      	add	sp, #12
 8002898:	bd00      	pop	{pc}
 800289a:	46c0      	nop			; (mov r8, r8)
 800289c:	0000      	movs	r0, r0
	...

080028a0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80028a0:	b500      	push	{lr}
 80028a2:	b083      	sub	sp, #12
 80028a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80028a6:	f7ff ff2b 	bl	8002700 <chSysLock.lto_priv.217>
  chThdExitS(msg);
 80028aa:	9b01      	ldr	r3, [sp, #4]
 80028ac:	0018      	movs	r0, r3
 80028ae:	f000 f807 	bl	80028c0 <chThdExitS>
  /* The thread never returns here.*/
}
 80028b2:	b003      	add	sp, #12
 80028b4:	bd00      	pop	{pc}
 80028b6:	46c0      	nop			; (mov r8, r8)
	...

080028c0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80028c0:	b500      	push	{lr}
 80028c2:	b085      	sub	sp, #20
 80028c4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80028c6:	4b16      	ldr	r3, [pc, #88]	; (8002920 <chThdExitS+0x60>)
 80028c8:	699b      	ldr	r3, [r3, #24]
 80028ca:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 80028cc:	9b03      	ldr	r3, [sp, #12]
 80028ce:	9a01      	ldr	r2, [sp, #4]
 80028d0:	621a      	str	r2, [r3, #32]
 80028d2:	e008      	b.n	80028e6 <chThdExitS+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80028d4:	9b03      	ldr	r3, [sp, #12]
 80028d6:	3324      	adds	r3, #36	; 0x24
 80028d8:	0018      	movs	r0, r3
 80028da:	f7ff fed1 	bl	8002680 <list_remove>
 80028de:	0003      	movs	r3, r0
 80028e0:	0018      	movs	r0, r3
 80028e2:	f7ff fd45 	bl	8002370 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80028e6:	9b03      	ldr	r3, [sp, #12]
 80028e8:	3324      	adds	r3, #36	; 0x24
 80028ea:	0018      	movs	r0, r3
 80028ec:	f7ff fe98 	bl	8002620 <list_notempty>
 80028f0:	1e03      	subs	r3, r0, #0
 80028f2:	d1ef      	bne.n	80028d4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80028f4:	9b03      	ldr	r3, [sp, #12]
 80028f6:	7f5b      	ldrb	r3, [r3, #29]
 80028f8:	001a      	movs	r2, r3
 80028fa:	2303      	movs	r3, #3
 80028fc:	4013      	ands	r3, r2
 80028fe:	d109      	bne.n	8002914 <chThdExitS+0x54>
    REG_REMOVE(tp);
 8002900:	9b03      	ldr	r3, [sp, #12]
 8002902:	695b      	ldr	r3, [r3, #20]
 8002904:	9a03      	ldr	r2, [sp, #12]
 8002906:	6912      	ldr	r2, [r2, #16]
 8002908:	611a      	str	r2, [r3, #16]
 800290a:	9b03      	ldr	r3, [sp, #12]
 800290c:	691b      	ldr	r3, [r3, #16]
 800290e:	9a03      	ldr	r2, [sp, #12]
 8002910:	6952      	ldr	r2, [r2, #20]
 8002912:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8002914:	200f      	movs	r0, #15
 8002916:	f7ff fd53 	bl	80023c0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 800291a:	b005      	add	sp, #20
 800291c:	bd00      	pop	{pc}
 800291e:	46c0      	nop			; (mov r8, r8)
 8002920:	20000668 	.word	0x20000668
	...
 8002930:	65726854 	.word	0x65726854
 8002934:	2c736461 	.word	0x2c736461
 8002938:	716e6520 	.word	0x716e6520
 800293c:	69756575 	.word	0x69756575
 8002940:	7420676e 	.word	0x7420676e
 8002944:	20747365 	.word	0x20747365
 8002948:	00003123 	.word	0x00003123
 800294c:	65726854 	.word	0x65726854
 8002950:	2c736461 	.word	0x2c736461
 8002954:	716e6520 	.word	0x716e6520
 8002958:	69756575 	.word	0x69756575
 800295c:	7420676e 	.word	0x7420676e
 8002960:	20747365 	.word	0x20747365
 8002964:	00003223 	.word	0x00003223
 8002968:	65726854 	.word	0x65726854
 800296c:	2c736461 	.word	0x2c736461
 8002970:	69727020 	.word	0x69727020
 8002974:	7469726f 	.word	0x7469726f
 8002978:	68632079 	.word	0x68632079
 800297c:	65676e61 	.word	0x65676e61
 8002980:	00000000 	.word	0x00000000
 8002984:	65726854 	.word	0x65726854
 8002988:	2c736461 	.word	0x2c736461
 800298c:	6c656420 	.word	0x6c656420
 8002990:	00737961 	.word	0x00737961
 8002994:	616d6553 	.word	0x616d6553
 8002998:	726f6870 	.word	0x726f6870
 800299c:	202c7365 	.word	0x202c7365
 80029a0:	75716e65 	.word	0x75716e65
 80029a4:	6e697565 	.word	0x6e697565
 80029a8:	00000067 	.word	0x00000067
 80029ac:	616d6553 	.word	0x616d6553
 80029b0:	726f6870 	.word	0x726f6870
 80029b4:	202c7365 	.word	0x202c7365
 80029b8:	656d6974 	.word	0x656d6974
 80029bc:	0074756f 	.word	0x0074756f
 80029c0:	616d6553 	.word	0x616d6553
 80029c4:	726f6870 	.word	0x726f6870
 80029c8:	202c7365 	.word	0x202c7365
 80029cc:	6d6f7461 	.word	0x6d6f7461
 80029d0:	73206369 	.word	0x73206369
 80029d4:	616e6769 	.word	0x616e6769
 80029d8:	61772d6c 	.word	0x61772d6c
 80029dc:	00007469 	.word	0x00007469
 80029e0:	616e6942 	.word	0x616e6942
 80029e4:	53207972 	.word	0x53207972
 80029e8:	70616d65 	.word	0x70616d65
 80029ec:	65726f68 	.word	0x65726f68
 80029f0:	66202c73 	.word	0x66202c73
 80029f4:	74636e75 	.word	0x74636e75
 80029f8:	616e6f69 	.word	0x616e6f69
 80029fc:	7974696c 	.word	0x7974696c
 8002a00:	00000000 	.word	0x00000000
 8002a04:	6574754d 	.word	0x6574754d
 8002a08:	2c736578 	.word	0x2c736578
 8002a0c:	69727020 	.word	0x69727020
 8002a10:	7469726f 	.word	0x7469726f
 8002a14:	6e652079 	.word	0x6e652079
 8002a18:	75657571 	.word	0x75657571
 8002a1c:	20676e69 	.word	0x20676e69
 8002a20:	74736574 	.word	0x74736574
 8002a24:	00000000 	.word	0x00000000
 8002a28:	6574754d 	.word	0x6574754d
 8002a2c:	2c736578 	.word	0x2c736578
 8002a30:	69727020 	.word	0x69727020
 8002a34:	7469726f 	.word	0x7469726f
 8002a38:	65722079 	.word	0x65722079
 8002a3c:	6e727574 	.word	0x6e727574
 8002a40:	00000000 	.word	0x00000000
 8002a44:	6574754d 	.word	0x6574754d
 8002a48:	2c736578 	.word	0x2c736578
 8002a4c:	61747320 	.word	0x61747320
 8002a50:	00737574 	.word	0x00737574
 8002a54:	646e6f43 	.word	0x646e6f43
 8002a58:	2c726156 	.word	0x2c726156
 8002a5c:	67697320 	.word	0x67697320
 8002a60:	206c616e 	.word	0x206c616e
 8002a64:	74736574 	.word	0x74736574
 8002a68:	00000000 	.word	0x00000000
 8002a6c:	646e6f43 	.word	0x646e6f43
 8002a70:	2c726156 	.word	0x2c726156
 8002a74:	6f726220 	.word	0x6f726220
 8002a78:	61636461 	.word	0x61636461
 8002a7c:	74207473 	.word	0x74207473
 8002a80:	00747365 	.word	0x00747365
 8002a84:	646e6f43 	.word	0x646e6f43
 8002a88:	2c726156 	.word	0x2c726156
 8002a8c:	6f6f6220 	.word	0x6f6f6220
 8002a90:	74207473 	.word	0x74207473
 8002a94:	00747365 	.word	0x00747365
 8002a98:	7373654d 	.word	0x7373654d
 8002a9c:	73656761 	.word	0x73656761
 8002aa0:	6f6c202c 	.word	0x6f6c202c
 8002aa4:	0000706f 	.word	0x0000706f
 8002aa8:	6c69614d 	.word	0x6c69614d
 8002aac:	65786f62 	.word	0x65786f62
 8002ab0:	71202c73 	.word	0x71202c73
 8002ab4:	69756575 	.word	0x69756575
 8002ab8:	6120676e 	.word	0x6120676e
 8002abc:	7420646e 	.word	0x7420646e
 8002ac0:	6f656d69 	.word	0x6f656d69
 8002ac4:	00737475 	.word	0x00737475
 8002ac8:	6e657645 	.word	0x6e657645
 8002acc:	202c7374 	.word	0x202c7374
 8002ad0:	69676572 	.word	0x69676572
 8002ad4:	61727473 	.word	0x61727473
 8002ad8:	6e6f6974 	.word	0x6e6f6974
 8002adc:	646e6120 	.word	0x646e6120
 8002ae0:	73696420 	.word	0x73696420
 8002ae4:	63746170 	.word	0x63746170
 8002ae8:	00000068 	.word	0x00000068
 8002aec:	6e657645 	.word	0x6e657645
 8002af0:	202c7374 	.word	0x202c7374
 8002af4:	74696177 	.word	0x74696177
 8002af8:	646e6120 	.word	0x646e6120
 8002afc:	6f726220 	.word	0x6f726220
 8002b00:	61636461 	.word	0x61636461
 8002b04:	00007473 	.word	0x00007473
 8002b08:	6e657645 	.word	0x6e657645
 8002b0c:	202c7374 	.word	0x202c7374
 8002b10:	656d6974 	.word	0x656d6974
 8002b14:	7374756f 	.word	0x7374756f
 8002b18:	00000000 	.word	0x00000000
 8002b1c:	70616548 	.word	0x70616548
 8002b20:	6c61202c 	.word	0x6c61202c
 8002b24:	61636f6c 	.word	0x61636f6c
 8002b28:	6e6f6974 	.word	0x6e6f6974
 8002b2c:	646e6120 	.word	0x646e6120
 8002b30:	61726620 	.word	0x61726620
 8002b34:	6e656d67 	.word	0x6e656d67
 8002b38:	69746174 	.word	0x69746174
 8002b3c:	74206e6f 	.word	0x74206e6f
 8002b40:	00747365 	.word	0x00747365
 8002b44:	6f6d654d 	.word	0x6f6d654d
 8002b48:	50207972 	.word	0x50207972
 8002b4c:	736c6f6f 	.word	0x736c6f6f
 8002b50:	7571202c 	.word	0x7571202c
 8002b54:	2f657565 	.word	0x2f657565
 8002b58:	75716564 	.word	0x75716564
 8002b5c:	00657565 	.word	0x00657565
 8002b60:	616e7944 	.word	0x616e7944
 8002b64:	2063696d 	.word	0x2063696d
 8002b68:	73495041 	.word	0x73495041
 8002b6c:	6874202c 	.word	0x6874202c
 8002b70:	64616572 	.word	0x64616572
 8002b74:	72632073 	.word	0x72632073
 8002b78:	69746165 	.word	0x69746165
 8002b7c:	66206e6f 	.word	0x66206e6f
 8002b80:	206d6f72 	.word	0x206d6f72
 8002b84:	70616568 	.word	0x70616568
 8002b88:	00000000 	.word	0x00000000
 8002b8c:	616e7944 	.word	0x616e7944
 8002b90:	2063696d 	.word	0x2063696d
 8002b94:	73495041 	.word	0x73495041
 8002b98:	6874202c 	.word	0x6874202c
 8002b9c:	64616572 	.word	0x64616572
 8002ba0:	72632073 	.word	0x72632073
 8002ba4:	69746165 	.word	0x69746165
 8002ba8:	66206e6f 	.word	0x66206e6f
 8002bac:	206d6f72 	.word	0x206d6f72
 8002bb0:	6f6d656d 	.word	0x6f6d656d
 8002bb4:	70207972 	.word	0x70207972
 8002bb8:	006c6f6f 	.word	0x006c6f6f
 8002bbc:	616e7944 	.word	0x616e7944
 8002bc0:	2063696d 	.word	0x2063696d
 8002bc4:	73495041 	.word	0x73495041
 8002bc8:	6572202c 	.word	0x6572202c
 8002bcc:	74736967 	.word	0x74736967
 8002bd0:	61207972 	.word	0x61207972
 8002bd4:	7220646e 	.word	0x7220646e
 8002bd8:	72656665 	.word	0x72656665
 8002bdc:	65636e65 	.word	0x65636e65
 8002be0:	00000073 	.word	0x00000073
 8002be4:	75657551 	.word	0x75657551
 8002be8:	202c7365 	.word	0x202c7365
 8002bec:	75706e69 	.word	0x75706e69
 8002bf0:	75712074 	.word	0x75712074
 8002bf4:	73657565 	.word	0x73657565
 8002bf8:	00000000 	.word	0x00000000
 8002bfc:	75657551 	.word	0x75657551
 8002c00:	202c7365 	.word	0x202c7365
 8002c04:	7074756f 	.word	0x7074756f
 8002c08:	71207475 	.word	0x71207475
 8002c0c:	65756575 	.word	0x65756575
 8002c10:	00000073 	.word	0x00000073
 8002c14:	74737953 	.word	0x74737953
 8002c18:	202c6d65 	.word	0x202c6d65
 8002c1c:	74697263 	.word	0x74697263
 8002c20:	6c616369 	.word	0x6c616369
 8002c24:	6e6f7a20 	.word	0x6e6f7a20
 8002c28:	00007365 	.word	0x00007365
 8002c2c:	74737953 	.word	0x74737953
 8002c30:	202c6d65 	.word	0x202c6d65
 8002c34:	65746e69 	.word	0x65746e69
 8002c38:	70757272 	.word	0x70757272
 8002c3c:	68207374 	.word	0x68207374
 8002c40:	6c646e61 	.word	0x6c646e61
 8002c44:	00676e69 	.word	0x00676e69
 8002c48:	74737953 	.word	0x74737953
 8002c4c:	202c6d65 	.word	0x202c6d65
 8002c50:	65746e69 	.word	0x65746e69
 8002c54:	74697267 	.word	0x74697267
 8002c58:	00000079 	.word	0x00000079
 8002c5c:	202d2d2d 	.word	0x202d2d2d
 8002c60:	726f6353 	.word	0x726f6353
 8002c64:	203a2065 	.word	0x203a2065
 8002c68:	00000000 	.word	0x00000000
 8002c6c:	67736d20 	.word	0x67736d20
 8002c70:	2c532f73 	.word	0x2c532f73
 8002c74:	00000020 	.word	0x00000020
 8002c78:	78746320 	.word	0x78746320
 8002c7c:	2f637773 	.word	0x2f637773
 8002c80:	00000053 	.word	0x00000053
 8002c84:	636e6542 	.word	0x636e6542
 8002c88:	72616d68 	.word	0x72616d68
 8002c8c:	6d202c6b 	.word	0x6d202c6b
 8002c90:	61737365 	.word	0x61737365
 8002c94:	20736567 	.word	0x20736567
 8002c98:	00003123 	.word	0x00003123
 8002c9c:	636e6542 	.word	0x636e6542
 8002ca0:	72616d68 	.word	0x72616d68
 8002ca4:	6d202c6b 	.word	0x6d202c6b
 8002ca8:	61737365 	.word	0x61737365
 8002cac:	20736567 	.word	0x20736567
 8002cb0:	00003223 	.word	0x00003223
 8002cb4:	636e6542 	.word	0x636e6542
 8002cb8:	72616d68 	.word	0x72616d68
 8002cbc:	6d202c6b 	.word	0x6d202c6b
 8002cc0:	61737365 	.word	0x61737365
 8002cc4:	20736567 	.word	0x20736567
 8002cc8:	00003323 	.word	0x00003323
 8002ccc:	636e6542 	.word	0x636e6542
 8002cd0:	72616d68 	.word	0x72616d68
 8002cd4:	63202c6b 	.word	0x63202c6b
 8002cd8:	65746e6f 	.word	0x65746e6f
 8002cdc:	73207478 	.word	0x73207478
 8002ce0:	63746977 	.word	0x63746977
 8002ce4:	00000068 	.word	0x00000068
 8002ce8:	72687420 	.word	0x72687420
 8002cec:	73646165 	.word	0x73646165
 8002cf0:	0000532f 	.word	0x0000532f
 8002cf4:	636e6542 	.word	0x636e6542
 8002cf8:	72616d68 	.word	0x72616d68
 8002cfc:	74202c6b 	.word	0x74202c6b
 8002d00:	61657268 	.word	0x61657268
 8002d04:	202c7364 	.word	0x202c7364
 8002d08:	6c6c7566 	.word	0x6c6c7566
 8002d0c:	63796320 	.word	0x63796320
 8002d10:	0000656c 	.word	0x0000656c
 8002d14:	636e6542 	.word	0x636e6542
 8002d18:	72616d68 	.word	0x72616d68
 8002d1c:	74202c6b 	.word	0x74202c6b
 8002d20:	61657268 	.word	0x61657268
 8002d24:	202c7364 	.word	0x202c7364
 8002d28:	61657263 	.word	0x61657263
 8002d2c:	6f206574 	.word	0x6f206574
 8002d30:	00796c6e 	.word	0x00796c6e
 8002d34:	73657220 	.word	0x73657220
 8002d38:	64656863 	.word	0x64656863
 8002d3c:	73656c75 	.word	0x73656c75
 8002d40:	202c532f 	.word	0x202c532f
 8002d44:	00000000 	.word	0x00000000
 8002d48:	636e6542 	.word	0x636e6542
 8002d4c:	72616d68 	.word	0x72616d68
 8002d50:	6d202c6b 	.word	0x6d202c6b
 8002d54:	20737361 	.word	0x20737361
 8002d58:	63736572 	.word	0x63736572
 8002d5c:	75646568 	.word	0x75646568
 8002d60:	202c656c 	.word	0x202c656c
 8002d64:	68742035 	.word	0x68742035
 8002d68:	64616572 	.word	0x64616572
 8002d6c:	00000073 	.word	0x00000073
 8002d70:	636e6542 	.word	0x636e6542
 8002d74:	72616d68 	.word	0x72616d68
 8002d78:	72202c6b 	.word	0x72202c6b
 8002d7c:	646e756f 	.word	0x646e756f
 8002d80:	626f7220 	.word	0x626f7220
 8002d84:	63206e69 	.word	0x63206e69
 8002d88:	65746e6f 	.word	0x65746e6f
 8002d8c:	73207478 	.word	0x73207478
 8002d90:	63746977 	.word	0x63746977
 8002d94:	676e6968 	.word	0x676e6968
 8002d98:	00000000 	.word	0x00000000
 8002d9c:	74796220 	.word	0x74796220
 8002da0:	532f7365 	.word	0x532f7365
 8002da4:	00000000 	.word	0x00000000
 8002da8:	636e6542 	.word	0x636e6542
 8002dac:	72616d68 	.word	0x72616d68
 8002db0:	49202c6b 	.word	0x49202c6b
 8002db4:	51204f2f 	.word	0x51204f2f
 8002db8:	65756575 	.word	0x65756575
 8002dbc:	68742073 	.word	0x68742073
 8002dc0:	67756f72 	.word	0x67756f72
 8002dc4:	74757068 	.word	0x74757068
 8002dc8:	00000000 	.word	0x00000000
 8002dcc:	6d697420 	.word	0x6d697420
 8002dd0:	2f737265 	.word	0x2f737265
 8002dd4:	00000053 	.word	0x00000053
 8002dd8:	636e6542 	.word	0x636e6542
 8002ddc:	72616d68 	.word	0x72616d68
 8002de0:	76202c6b 	.word	0x76202c6b
 8002de4:	75747269 	.word	0x75747269
 8002de8:	74206c61 	.word	0x74206c61
 8002dec:	72656d69 	.word	0x72656d69
 8002df0:	65732073 	.word	0x65732073
 8002df4:	65722f74 	.word	0x65722f74
 8002df8:	00746573 	.word	0x00746573
 8002dfc:	69617720 	.word	0x69617720
 8002e00:	69732b74 	.word	0x69732b74
 8002e04:	6c616e67 	.word	0x6c616e67
 8002e08:	0000532f 	.word	0x0000532f
 8002e0c:	636e6542 	.word	0x636e6542
 8002e10:	72616d68 	.word	0x72616d68
 8002e14:	73202c6b 	.word	0x73202c6b
 8002e18:	70616d65 	.word	0x70616d65
 8002e1c:	65726f68 	.word	0x65726f68
 8002e20:	61772073 	.word	0x61772073
 8002e24:	732f7469 	.word	0x732f7469
 8002e28:	616e6769 	.word	0x616e6769
 8002e2c:	0000006c 	.word	0x0000006c
 8002e30:	636f6c20 	.word	0x636f6c20
 8002e34:	6e752b6b 	.word	0x6e752b6b
 8002e38:	6b636f6c 	.word	0x6b636f6c
 8002e3c:	0000532f 	.word	0x0000532f
 8002e40:	636e6542 	.word	0x636e6542
 8002e44:	72616d68 	.word	0x72616d68
 8002e48:	6d202c6b 	.word	0x6d202c6b
 8002e4c:	78657475 	.word	0x78657475
 8002e50:	6c207365 	.word	0x6c207365
 8002e54:	2f6b636f 	.word	0x2f6b636f
 8002e58:	6f6c6e75 	.word	0x6f6c6e75
 8002e5c:	00006b63 	.word	0x00006b63
 8002e60:	202d2d2d 	.word	0x202d2d2d
 8002e64:	74737953 	.word	0x74737953
 8002e68:	203a6d65 	.word	0x203a6d65
 8002e6c:	00000000 	.word	0x00000000
 8002e70:	74796220 	.word	0x74796220
 8002e74:	00007365 	.word	0x00007365
 8002e78:	202d2d2d 	.word	0x202d2d2d
 8002e7c:	65726854 	.word	0x65726854
 8002e80:	203a6461 	.word	0x203a6461
 8002e84:	00000000 	.word	0x00000000
 8002e88:	202d2d2d 	.word	0x202d2d2d
 8002e8c:	656d6954 	.word	0x656d6954
 8002e90:	203a2072 	.word	0x203a2072
 8002e94:	00000000 	.word	0x00000000
 8002e98:	202d2d2d 	.word	0x202d2d2d
 8002e9c:	616d6553 	.word	0x616d6553
 8002ea0:	203a6870 	.word	0x203a6870
 8002ea4:	00000000 	.word	0x00000000
 8002ea8:	202d2d2d 	.word	0x202d2d2d
 8002eac:	6e657645 	.word	0x6e657645
 8002eb0:	203a5374 	.word	0x203a5374
 8002eb4:	00000000 	.word	0x00000000
 8002eb8:	202d2d2d 	.word	0x202d2d2d
 8002ebc:	6e657645 	.word	0x6e657645
 8002ec0:	203a4c74 	.word	0x203a4c74
 8002ec4:	00000000 	.word	0x00000000
 8002ec8:	202d2d2d 	.word	0x202d2d2d
 8002ecc:	6574754d 	.word	0x6574754d
 8002ed0:	203a2078 	.word	0x203a2078
 8002ed4:	00000000 	.word	0x00000000
 8002ed8:	202d2d2d 	.word	0x202d2d2d
 8002edc:	646e6f43 	.word	0x646e6f43
 8002ee0:	203a2e56 	.word	0x203a2e56
 8002ee4:	00000000 	.word	0x00000000
 8002ee8:	202d2d2d 	.word	0x202d2d2d
 8002eec:	75657551 	.word	0x75657551
 8002ef0:	203a2065 	.word	0x203a2065
 8002ef4:	00000000 	.word	0x00000000
 8002ef8:	202d2d2d 	.word	0x202d2d2d
 8002efc:	6c69614d 	.word	0x6c69614d
 8002f00:	203a2e42 	.word	0x203a2e42
 8002f04:	00000000 	.word	0x00000000
 8002f08:	636e6542 	.word	0x636e6542
 8002f0c:	72616d68 	.word	0x72616d68
 8002f10:	52202c6b 	.word	0x52202c6b
 8002f14:	66204d41 	.word	0x66204d41
 8002f18:	70746f6f 	.word	0x70746f6f
 8002f1c:	746e6972 	.word	0x746e6972
 8002f20:	00000000 	.word	0x00000000
 8002f24:	0044454c 	.word	0x0044454c
	...
 8002f30:	656c6469 	.word	0x656c6469
	...

08002f40 <ram_areas.lto_priv.258>:
 8002f40:	080030f8 20000a60 20000a60 20000a60     .0..`.. `.. `.. 
 8002f50:	080030f8 00000000 00000000 00000000     .0..............
 8002f60:	080030f8 00000000 00000000 00000000     .0..............
 8002f70:	080030f8 00000000 00000000 00000000     .0..............
 8002f80:	080030f8 00000000 00000000 00000000     .0..............
 8002f90:	080030f8 00000000 00000000 00000000     .0..............
 8002fa0:	080030f8 00000000 00000000 00000000     .0..............
 8002fb0:	080030f8 00000000 00000000 00000000     .0..............

08002fc0 <ch_debug>:
 8002fc0:	6e69616d 18441600 08440404 1814100c     main..D...D.....
 8002fd0:	1e1d1c00 00000000 00000000 00000000     ................

08002fe0 <vmt.lto_priv.145>:
 8002fe0:	08000e91 08000ec1 08000ef1 08000f21     ............!...
 8002ff0:	08000f41 08000f71 08000f91 08000fc1     A...q...........

08003000 <pal_default_config>:
 8003000:	2800a10a 00000000 ffffffff 65555555     ...(........UUUe
 8003010:	0000ffef 11000022 00000000 00000008     ...."...........
 8003020:	00000000 ffffffff 55555555 0000ffff     ........UUUU....
 8003030:	00000010 00000000 00000000 00000000     ................
 8003040:	ffffffff 55555555 0000ffff 00000000     ....UUUU........
 8003050:	00000000 00000005 00000000 ffffffff     ................
 8003060:	55555555 0000fffc 00000000 00000000     UUUU............
 8003070:	08002430 08002452 08002452 08002436     0$..R$..R$..6$..
 8003080:	0800244a 08002440 08002452 0800244a     J$..@$..R$..J$..
